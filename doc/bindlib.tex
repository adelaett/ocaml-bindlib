\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{ocamldoc}
\usepackage{textcomp}

\title{
  Bindlib, version 4.0 \\
  A package for abstract syntax with binder
}
\author{
  Christophe Raffalli \& Rodolphe Lepigre \\
  Université Savoie Mont Blanc
}

\begin{document}
\maketitle

\vspace{1cm}
\begin{abstract}
  Bindlib is an \verb#OCaml# library providing a set of tools for managing
  data structures with (bound and free) variables. It is very well suited for
  defining abstract syntax trees.
  %
  Bindlib includes support for fast substitutions and for the management of
  variables names. In particular, bound variables are renamed in a minimal
  way to avoid capture.
\end{abstract}
\vspace{1cm}

\tableofcontents

\section{Introduction}

Data structures with bound and free variables are very common in computer
science. For instance, they are required to encode mathematical formulas or
computer programs into so-called abstract syntax trees. The manipulation of
bound and free variables is hence essential when it comes to writing
compilers or proof assistants. However, implementing the necessary primitives
(mainly capture-avoiding substitution and renaming) is cumbersome. Moreover,
the simplest implementations often result in poor performance, especially
when a lot of substitutions are required. Bindlib aims at providing a library
that enables both simplicity and efficiency. It provides high-level tools to
deal with binders, substitutions and free variables.

This documentation is in two parts : an informal presentation
introducing each concept step by step illustrated with examples. Then,
a more formal presentation in the appendix which includes the syntax
and an equational semantics of the library.

For our first example, we assume basic knowledge of the $\lambda$-calculus
which is the simplest data structure with bound variables (Wikipedia
has a good introduction on this topic). For the second example, we
will give the required mathematical definitions.

\section{Using and installing}

Bindlib works with \verb#OCaml# version 3.12.1 or later, but it has not been
tested with earlier versions. It can be compiled and installed using the
command
\begin{center}
  \verb#make && make install#
\end{center}
in the source directory. Alternatively, Bindlib can be installed using the
\verb#opam# package manager using the following command.
\begin{center}
  \verb#opam install bindlib#
\end{center}

Several examples of applications (including an implementation of the
$\lambda$-calculus) are provided in Bindlib's source directory (or in
\verb#opam#'s doc directory if you installed via \verb#opam#).

\section{Basic types}

The main type constructors and function provided by Bindlib are
\begin{itemize}
\item \verb#'a variable# represent a variable in the type \verb#'a#.
\item \verb#('a,'b) binder# corresponds to a value of type \verb#'b# with one bound variable of type
  \verb#'a#
\item \verb#subst : ('a, 'b) binder -> 'a -> 'b# performing
  substitution of bound variables.
\item \verb#'a bindbox# represent a term with free variables. This is
  the main concept to understand, because value of type
  \verb#('a,'b) binder# can not be constructed directly. On must
  construct them with type \verb#('a,'b) binder bindbox#. Therefore,
  bindlib provide the following functions to be able to build value of
  type \verb#'a bindbox#.

\item \verb#new_var :   ('a variable -> 'a) -> string -> 'a variable#
  creating a new variable from an initial name (that may change if
  necessary) and a function that we can ignore for now
    (it can often be \verb#fun _ -> assert false#).

\item \verb#box_of_var : 'a variable -> 'a bindbox# to use a variable
  inside a value of type \verb#'a#.

\item
  \verb#vbind : ('a variable -> 'a) -> 'a variable -> 'b bindbox -> ('a, 'b) binder bindbox#.
  If we ignore as above the first function argument (which can often
  be \verb#fun _ -> assert false#), \verb#vbind f v t# bind the
  variable \verb#v# in the term \verb#t#.

\item Bindlib also provides a few function to use predefined OCaml
  functions under the \verb#bindbox# type constructore like:
  \begin{itemize}
  \item
    \verb#apply_box : ('a -> 'b) bindbox -> 'a bindbox -> `'b bindbox#
  \item \verb#box : 'a -> 'a bindbox#
  \item \verb#box_array : 'a bindbox array -> 'a array bindbox#
  \item …
  \end{itemize}
\end{itemize}

\section{How to use a data structure with variables ?}

For now, we will analyse an exemple using a data structure with
binders. We will therefore not need the \verb#bindbox# type constructor.

We first define the type of $\lambda$-terms as follows.
\begin{quote}
\begin{verbatim}
type term =
  | App of term * term         (* application                 *)
  | Lam of (term, term) binder (* abstraction (i.e. function) *)
  | Var of term variable       (* free variable               *)
\end{verbatim}
\end{quote}

Consider the following function to convert lambda-terms to string:

\begin{quote}
\begin{verbatim}
let fVar x = Var(x)

let rec term_to_string = function
  | Var x    -> name_of x
  | Lam b    -> let (x,t) = unbind fVar b in
                "\\" ^ (name_of x) ^ (term_to_string t)
  | App(t,u) -> (term_to_string t) ^ "(" ^ (term_to_string u) ^ ")"
\end{verbatim}
\end{quote}

The function \verb!fVar! is just a synonymous of the type constructor
\verb!Var! that can be easily passed in argument to functions like
\verb#new_var# or \verb#vbind# because it as the expected type
\verb#term variable -> term#. We will see how it is use later ...
In this example, \verb!fVar! is not used and it is possible to
replace it by \verb!(fun _ -> assert false)!.

Printing application is immediate, just recursive calls. All cases not
dealing with bindlib's type constructor should be straightforward. For
variables, bindlib manages function name and renaming and provide a
function \verb!name_of : 'a variable -> string! to get the variable name.

For binder, one may use
\begin{quote}
\begin{verbatim}
unbind : ('a, 'b) binder -> ('a variable -> 'a) -> 'a variable *'b
\end{verbatim}
\end{quote}
% A natural question arises: what is the
% role of the first argument of \verb!unbind!. It is mandatory when
% constructing a value of type \verb!'a variable! to provide a function
% of type \verb!'a variable -> 'a!, which is used when we need to
% consider the variable as an object of type \verb!'a!.

The function \verb!let (x,t) = unbind fVar b in! could be replaced by the following lines:
\begin{quote}
\begin{verbatim}
let name = binder_name f in
let x = new_var name fVar x in
let t = subst f (free_of x) in
\end{verbatim}
\end{quote}


These lines use the following new functions:

\begin{itemize}
\item \verb#binder_name : ('a, 'b) binder -> string# to get the name
  of the bound variable that is kept and managed by bindlib.

%\item \verb#new_var# is a function to create a new variable.
%The name you give is only an indication, it might be changed by
%bindlib if necessary, but will be always kept as prefix.

\item \verb#free_of x# is in fact equivalent to \verb#fVar x#.
We can now reveal one of the use of the first argument of
\verb#new_var#: \verb#free_of x# is equivalent to \verb#f x# when
\verb#f# we use as first argument to create the variable.

%\item \verb#subst : ('a, 'b) binder -> 'a -> 'b# is finally use to
%  substitute a value in place of the bound variable in \verb#f#.
\end{itemize}


\section{How to construct a data structure with variables ?}

To construct data structure with bound variables, we now need the
\verb!'a bindbox!
type constructor.

\verb!'a bindbox! is the type of a data structure of type \verb#'a# under
construction.

Using a type \verb!'a bindbox! when constructing a data structure with
bound variables is the main idea behind bindlib. As an approximation,
you can view a value of type \verb!'a bindbox! as a pair with a set
of bound variables, and a function that builds a value of type \verb!'a!
from the value of all these variabes.

Working with \verb!'a bindbox! requires to lift the constructor to
this type. Indeed, we need some kind of way to transform the
\verb!App! constructor into a term of type
\begin{center}
  \verb!term bindbox -> term bindbox -> term bindbox!.
\end{center}
The bindlib library
provide the necessary function to do that in a few lines:

\begin{quote}
\begin{verbatim}
let app : term bindbox -> term bindbox -> term bindbox =
  fun x y -> box_apply2 (fun x y -> App(x,y)) x y
let lam : string -> (term bindbox -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x))
    (let v = new_var fVar name in bind_var v (f (free_of v)))
\end{verbatim}
\end{quote}

Those \emph{smart constructors} are build using the following new functions:
\begin{quote}
\begin{verbatim}
bind_var : 'a variable  -> 'b bindbox -> ('a, 'b) binder bindbox
box_apply : ('a -> 'b) -> 'a bindbox -> 'b bindbox#
box_apply2 : ('a -> 'b -> 'c) -> 'a bindbox -> 'b bindbox -> 'c
\end{verbatim}
\end{quote}

The key function to bind variables is \verb#bind_var#. Two short cuts
are provided:
\begin{quote}
\begin{verbatim}
let bind fv name f =
  let v = new_var fVar name in bind_var v (f (box_of_var v))
let vbind fv name f =
  let v = new_var fVar name in bind_var v (f v)
\end{verbatim}
\end{quote}

Using these short cuts, we could give a shorter definition and an
alternative version of \verb#lam#:

\begin{quote}
\begin{verbatim}
let lam : string -> (term bindbox -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x)) (bind fVar name f)
let vlam : string -> (term variable -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x)) (vbind fVar name f)
\end{verbatim}
\end{quote}

Depending what we do when we construct a term, we might prefer
the bound variables to be directly of type \verb#term bindbox# as in
\verb#lam# or of type \verb#term variable# as in the latest definition.

Using these \emph{smart constructors}, we can start to define value of
type term. We also need the function \verb#unbox : 'a bindbox -> 'a#
to finalise the construction.
\begin{quote}
\begin{verbatim}
let idt = unbox (lam "x" (fun x -> x))
let delta = unbox (lam "x" (fun x -> app x x))
let omega = App(delta,delta)
\end{verbatim}
\end{quote}

Remark: in the last definition, because we are not binding any new
variables, we do not need to work inside the type \verb#'a bindbox#.

Here is another example, which performs the following transformation on
$\lambda$-term (it marks all the applications with a variable and bind this variable):
$$
\begin{array}{rcl}
\hbox{mark}(t) &=& \lambda x.\phi_x(t) \cr
\phi_x(y) &=& y \cr
\phi_x(u\,v) &=& x\,\phi_x(u)\,\phi_x(v) \cr
\phi_x(\lambda y.u) &=& \lambda y.(\phi_x u)
\end{array}
$$

Here is the corresponding code, which illustrates the different use
of \verb#lam# and \verb#vlam#:

\begin{verbatim}
let mark t =
  let rec phi x = function
  | Var(y) -> box_of_var y
  | App(u,v) -> app (app x (phi x u)) (phi x v)
  | Lam(f) -> vlam (binder_name f) (fun y -> phi x (subst f (Var y)))
  in unbox (lam "x" (fun x -> phi x t))
\end{verbatim}

This code is very similar to the mathematical definition.
The use of \verb#binder_name f# allows to use the original name
(eventually with a changed suffix).

Here is another example: the computation of the normal form of a term:

\begin{verbatim}
(* weak head normal form *)
let rec whnf = function
  App(t1,t2) as t0 -> (
    match (whnf t1) with
    | Lam f -> whnf (subst f t2)
    | t1' ->
       (* a small optimization here when the term is in whnf *)
       if t1' == t1 then t0 else App(t1', t2))
| t -> t

(* call by name normalisation, all step at once *)
let norm t = let rec fn t =
  match whnf t with
  | Lam f ->
      let (x,t) = unbind fVar f in
      vlam (binder_name f) (fun x -> fn (subst f (Var x)))
  | t ->
      let rec unwind = function
        | Var(x) -> box_of_var x
        | App(t1,t2) -> app (unwind t1) (fn t2)
        | t -> assert false
      in unwind t
in unbox (fn t)
\end{verbatim}

This function is very similar to the previous one, with one function
to compute the ``weak head normal form'', which is used in the second
function to compute the full normal form.

\section{Naming of variables}

The bindlib library uses \verb#string# for variable names. Names are
considered
as the concatenation of a prefix and a possibly empty suffix. The
suffix is the longest terminal substring of the name composed only of
digits.

Example: in \verb#"toto0"# the suffix is \verb#"0"#.

To choose the initial name of a variable, you passe it to
\verb#new_var#, \verb#bind# or \verb#vbind# as second argument.

When binding \verb#x# using \verb#bind_var v t#, the suffix of
the name may be changed to avoid name conflict.
To access the name of variables, bindlib provides the following
functions:

\begin{itemize}
\item \verb#name_of : 'a variable -> string# to access the name of a free
  variable.

\item \verb#binder_name : ('a, 'b) variable -> string# to access the
  name of a bound variable.
\end{itemize}

Using bindlib you are sure that bound variables are renamed to avoid
variable conflict. But this is not enough:
\begin{enumerate}
\item Distinct free variables may have the same name. Renaming of free
  variables can not be done automatically because there is no way to
  know the variables that are used in the same ``context''.
\item The \verb#subst# function does not perform renaming. Therefore,
  it is only just after the call to \verb#unbox# that the bound
  variables are named correctly. If you use the result of \verb#unbox#
  and perform substitution then, the naming may become incorrect.

  This can not be avoided if one want a reasonable complexity for
  substitution.

\item By default, bindlib perform minimal renaming. This means it
  accepts name collision in \verb#fun x -> fun x -> x# that you might prefer printed as
\verb#fun x -> fun x0 -> x0#.
\end{enumerate}

To solve these problems, bindlib provides an abstract notion of context
 which are ``sets'' of free variables which should have
 distinct names.
\begin{itemize}
\item\verb#type ctxt# is  an abstract type.
\item\verb#empty_ctxt : ctxt# is the initial empty context.
\item\verb#new_var_in : ctxt -> ('a variable -> 'a) -> string -> 'a variable * ctxt#\\
  which is the same as \verb#new_var#, excep that it receives a
  context, renames the variable so the its name is not use in the
  context and returns a new context where this variable was added.
\item there exists also two variant of \verb#bind# and \verb#vbind#
  named \verb#bind_in# and \verb#vbind_in#
\end{itemize}

This fixes point (1). For the two other points, there are two solutions,
depending if you prefer minimal renaming or the so called Barendregt
convention (no bound variable should have the same name than a free
variable, even is the later does not occur in the scope of the
former).

If you want to follow Barendregt convention, this is easy, your
printing functions should use a \verb#ctxt# as in:

\begin{verbatim}
let rec term_to_string ctxt = function
  | Var x    -> name_of x
  | Lam b    -> let (x,t,ctxt) = unmbind ctxt fVar b in
                "\\" ^ (name_of x) ^ (term_to_string ctxt t)
  | App(t,u) -> (term_to_string ctxt t) ^ "(" ^ (term_to_string ctxt u) ^ ")"
\end{verbatim}

If you prefer minimal renaming, you have nothing to do if you are
certain that no substitution have been performed. Otherwise, you need
what I call a ``lifting'' function to copy the data structure before
printing as in the following example:

\begin{verbatim}
(* lifting *)
let rec lift_term = function
  | Var(y) -> box_of_var y
  | App(u,v) -> app (lift_term u)  (lift_term v)
  | Lam(f) ->
      vlam (binder_name f) (fun x -> lift_term (subst f (Var x)))

(* Printing function. *)
let rec print_term ch = function
  | Var x    -> Printf.fprintf ch "%s" (name_of x)
  | Lam b    -> let (x,t) = unbind b in
                Printf.fprintf ch "fun %s -> %a" (name_of x) print_term t
  | App(t,u) -> Printf.fprintf ch "(%a) %a" print_term t print_term u
let print_term t =
  Printf.printf "%a\n%!" print_term (unbox (lift_term t))
\end{verbatim}

\section{A more complete example and advanced features}

This section covers advanced feature of the library. The reader is
advised to read, practice and understand the previous section before
reading this.

We will consider second order predicate logic.
We chose this example, because the definition of second-order
substitution is non trivial ... and this is a very good example for
the power of \verb#bindlib#.

Here is the mathematical definition of terms and formulas, and the
corresponding definition using \verb#bindlib#:

\newtheorem{definition}{definition}\
\begin{definition}[Syntax of second order logic]\rm
We assume a signature
$$\Sigma = \{(f,1), (g,2), (a,0), \dots\}$$ with various
constants and function symbols of
various arity. An infinite set of first-order variables (written
$x,y,z\dots$) and for each natural number $n$ an infinite set of
second-order variables of arity $n$ (written $X,Y,Z,\dots$).

Terms are defined by
\begin{itemize}
\item $x$ is a term if it is a first order variable
\item $f(t_1,\dots,t_n)$ is a term if $f$ is a function symbol of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\end{itemize}

Formulas are defined by
\begin{itemize}
\item $X(t_1,\dots,t_n)$ is a formula if $X$ is a second order variable of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\item $A \to B$ is a formula if $A$ and $B$ are formulas.
\item $\forall x\,A$ is a formula with $x$ bound if $A$ is a formula
and $x$ is a first-order variable.
\item $\forall X\,A$ is a formula with $X$ bound if $A$ is a formula
and $X$ is a second-order variable.
\end{itemize}
\end{definition}

\begin{verbatim}
(* A structure representing a function symbol. *)
type symbol = { name : string ; arity : int }

(* The type of first order terms. *)
type term =
  | Var of term variable
  | Fun of symbol * term array

(* The type of formulas. *)
type form =
  (* Implication. *)
  | Imply of form * form
  (* First-order universal quantification. *)
  | Univ1 of (term, form) binder
  (* Second-order universal quantification. *)
  | Univ2 of int * (pred, form) binder
  (* Variable. *)
  | FVari of pred variable * term array

(* Predicate (implemented as a binder). *)
and pred = (term, form) mbinder

let fvar1 : term variable -> term = fun x -> Var x

let fvar2 : int -> pred variable -> pred = fun arity x ->
  let vs = Array.init arity (Printf.sprintf "x%i") in
  let f xs = box_apply (fun y -> FVari(x,y)) (box_array xs) in
  unbox (mbind fvar1 vs f)
\end{verbatim}

Let us review these definitions:
\begin{itemize}
\item \verb#pred = (term, form) mbinder#: this is the type of an object
of type \verb#form# with an array of bound variables. We use this to
represent predicates, that is formula with $n$ parameters.

\item \verb#Univ2 of int * (pred, form) binder#: for second order
quantification, we bind a variable of arity $n$. The arity is the
first argument of the constructor. For the second argument,
\verb#(pred, form) binder#, we mean that we bind a ``predicate''
variable. This variable is
itself a \verb#mbinder#, this is why it is a ``second-order'' variable.

\item \verb#FVari of pred variable * term array#: as usual
for any free variable, we have to store
the variable itself of type \verb#pred variable#.
But here, we should also store the terms which
are the arguments of the second-order predicate variable.

\item \verb#let fvar1 : term variable -> term = fun x -> Var x#: we introduce the
function to construct first-order variable. Every time we will want to
construct a first-order quantification, we will have to pass fvar1 to
the binding function.

\item \verb#mbind : ('a variable -> 'a) -> string array  -> ('a bindbox array -> 'b bindbox) -> ('a,'b) mbinder bindbox# is
  the main function to build multiple binder. The array of names give
  the name of the bound variables and the arity of this multiple binder.

\item \verb#box_array# : this is a function of type
  \verb#'a bindbox array -> 'a array binxbox#, which is often used when
  binding array of variables.

\item \verb#let fvar2 ...#: is the anlogous function for second order
  variable. It is more complex, because a second order variable is a
  binder. We must construct a binder with \verb#mbind# and provide for
  it \verb#fvar1# as we bind variable of type term, an array of names for
  printing
  (but its size gives the arity of the predicate variable) and
  finally, the function \verb#f# from which we build the binder. The wanted
  type for \verb#f# is \verb#term bindbox array -> form# and it is not
  too hard to assemble \verb#box_apply#, \verb#FVari# and
  \verb#box_array# to get it right.

  We end with \verb#unbox# to remove the \verb#bindbox# type
  constructor as no free variables remain.
\end{itemize}

FIXME BELOW IS NOT UP TO DATE

Now, we write the printing function for terms and formulas:

\begin{verbatim}
let rec print_term = function
    Fun(sy, ta) ->
      print_string sy.name;
      print_string "(";
      for i = 0 to sy.arity - 1 do
        print_term ta.(i);
        print_string (if i < sy.arity - 1 then "," else ")")
      done
  | TermVar(var) ->
      print_string (name_of var)

let rec print_form lvl = function
    Imply(f1, f2) ->
      if lvl > 0 then print_string "(";
      print_form 1 f1; print_string " => "; print_form lvl f2;
      if lvl > 0 then print_string ")";
  | Forall1 f ->
      match f with bind lam1 t  in g ->
        print_string "Forall1 ";
        print_string (name_of t);
        print_string " ";
        print_form 1 g
  | Forall2 (arity, f) ->
      match f with bind (lam2 arity) x in g ->
      print_string "Forall2 ";
      print_string (name_of x);
      print_string " ";
      print_form 1 g
  | FormVar(var,args) ->
      print_string (name_of var);
      print_string "(";
      let arity = Array.length args in
      for i = 0 to arity - 1 do
        print_term args.(i);
        print_string (if i < arity - 1 then "," else ")")
      done
\end{verbatim}

We also write the equality test which is similar:
\begin{verbatim}
let rec equal_term t t' = match t, t' with
    TermVar(x), TermVar(x') -> x == x'
  | Fun(sy,ta), Fun(sy',ta') when sy = sy' ->
      let r = ref true in
      for i = 0 to sy.arity - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false

let rec equal_form f f' = match f, f' with
    Imply(f,g), Imply(f',g') ->
      equal_form f f' && equal_form g g'
  | Forall1(f), Forall1(f') ->
      match f with bind lam1 t in g ->
      equal_form g (subst f' (free_of t))
  | Forall2(arity,f), Forall2(arity',f') ->
      arity = arity' &&
      match f with bind (lam2 arity) x in g ->
      equal_form g (subst f' (free_of x))
  | FormVar(x,ta), FormVar(x',ta') ->
      x == x' &&
      let r = ref true in
      for i = 0 to Array.length ta - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false
\end{verbatim}

One remark here: we do not use the variables names for comparison
(because it is slower and for another reason that we will see later),
but instead we use physical equality on the free variables we create to substitute to
bound variables.
It is possible to use structural equality because a
variable is a structure whose first field is a unique identifier. But
you should be aware that one of the field of this structure is an ML
closure (the function of type \verb#'a variable -> 'a# given when
creating the variable).

Now, we give the lifting functions (already mentioned about naming): very often, we have
an object \verb#o# of type \verb#t bindbox# that we want to
read/match. Therefore, we will use \verb#unbox#.
But then, we will want to reuse the subterms of \verb#o# with
type  \verb#t bindbox# to continue the construction of an object of
type \verb#t# with some bound variables. For this, we need this kind
of copying functions:

\begin{verbatim}
let rec lift_term = function
    TermVar(x) -> bindbox_of x
  | Fun(sy,ta) -> Fun(^ (^sy^), lift_array (Array.map lift_term ta) ^)

let rec lift_form = function
    Imply(f1,f2) -> Imply(^ lift_form f1, lift_form f2 ^)
  | Forall1 f ->
      match f with bind lam1 t in g ->
       Forall1(^ bindvar t in lift_form g ^)
  | Forall2(arity,f) ->
      match f with bind (lam2 arity) x in g ->
      Forall2(^ (^arity^), bindvar x in lift_form g ^)
  | FormVar(x,args) ->
      mbind_apply (bindbox_of x) (lift_array (Array.map lift_term args))
\end{verbatim}

The functions
\verb#bind_apply : ('a -> 'b) binder bindbox -> 'a bindbox -> 'b bindbox# and
\verb#mbind_apply  ('a -> 'b) mbinder bindbox -> 'a bindbox array -> 'b bindbox#
for multiple binder are
used to apply to its arguments a variable representing a binder.

Now we define proofs (for natural deduction):
\begin{verbatim}
type proof =
    Imply_intro of form * (proof,proof) binder
  | Imply_elim of proof * proof
  | Forall1_intro of (term, proof) binder
  | Forall1_elim of proof * term
  | Forall2_intro of int * (pred, proof) binder
  | Forall2_elim of proof * pred
  | Axiom of form * proof variable

let assume f x = Axiom(f,x)
\end{verbatim}

We remark that all introduction rules are binder and the
implication introduction rule binds a proof inside a proof.
For the function \verb#assume# constructing the variables of type
\verb#proof#, we also store the formula that it ``assumes'' when we do
the introduction of an implication.

Now, we give a simple function to print goals (or sequent), that is a
list of named hypotheses, represented by proof variables, and a
conclusion. We need to copy the hypotheses because they result from a
substitution. This is not the case for the conclusion of the sequent
which is passed to \verb#print_goal# just after the call to \verb#unbox#.
\begin{verbatim}
let print_goal hyps concl =
  List.iter (
  function
      Axiom(f, v) ->
        print_string (name_of v); print_string ":=";
        print_form 0 (unbox (lift_form f)); print_newline ()
    | _ ->
        failwith ("not an axiom")) hyps;
  print_string "  |- "; print_form 0 concl; print_newline ()
\end{verbatim}

Now the main function, that checks if a proof is correct. The first
function builds the formula which is proved by a proof, or raise the
exception \verb#Bad_proof# if the proof is incorrect.

The second function calls the first one and checks if the produced
formula is equal to a given formula.

Moreover, to illustrate the problem of variables names, we print the
goal which is obtained after each rule.

Here is the code that we will explain bellow:
\begin{verbatim}
exception Bad_proof of string

let type_infer p =
  let ctxt = empty_ctxt in
  let rec fn hyps ctxt p =
    let r = match p with
      Imply_intro(f,p) ->
        match p with bind (assume f) ax for ctxt in p' ->
        Imply(^ lift_form f, fn (ax::hyps) ctxt p' ^)
    | Imply_elim(p1, p2) ->
        begin
          let f1' = unbox (fn hyps ctxt p2) in
          match unbox (fn hyps ctxt p1) with
            Imply(f1,f2) when equal_form f1 f1' -> lift_form f2
          | Imply(f1,f2) ->
              print_form 0 f1; print_string "<>"; print_form 0 f1';
              print_newline ();
              raise (Bad_proof("Imply"))
          | _ ->
              raise (Bad_proof("Imply"))
        end
    | Forall1_intro(p) ->
        match p with bind lam1 t for ctxt in p' ->
        Forall1(^ bindvar t in  fn hyps ctxt p'^)
    | Forall1_elim(p,t) ->
        begin
          match unbox (fn hyps ctxt p) with
            Forall1(f) -> lift_form (subst f t)
          | _ -> raise (Bad_proof("Forall1"))
        end
    | Forall2_intro(arity, f) ->
        match f with bind (lam2 arity) x for ctxt in p' ->
        Forall2(^ (^arity^),  bindvar x in fn hyps ctxt p' ^)
    | Forall2_elim(p,pred) ->
        begin
          match unbox (fn hyps ctxt p) with
n            Forall2(arity, f) when arity = mbinder_arity pred ->
              lift_form (subst f pred)
          | _ -> raise (Bad_proof("Forall2"))
        end
    | Axiom(f,_) ->
        lift_form f
    in
    print_goal (List.map free_of hyps) (unbox r); print_newline ();
    r
  in
  unbox (fn [] ctxt p)

let type_check p f =
  if not (equal_form (type_infer p) f) then raise (Bad_proof "conclusion")
\end{verbatim}

There are two important things to comment in these programs:
\begin{enumerate}
\item We care about variable names using a context for the free
  variables and the \verb#lift_form# function for the bound ones as explained
  before.

\item The second important point is the use of \verb#unbox# together
with the \verb#lift_form# function to type-check the elimination rules.

We must use \verb#unbox# to match the formula coming from the
type-checking of the principal premise of the rule. Then, one
sub-formula of the matched formula must be used and we have to use
\verb#lift_form# for that.
Important remark: because of the use of \verb#lift_term# and
\verb#lift_form# functions, this algorithm is quadratic (at least), because
it calls \verb#lift_term# and \verb#lift_form# which are linear at
each elimination rule. As an exercise, the reader could rewrite the
\verb#type_infer# function, using a stack, to avoid this.

It is in fact a general problem when writing programs using bound
variables, we have often to make copy of objects (to adjust DeBruijn
indices, to rename variables, to ``relift'' them). And this is
important that \verb#bindlib# allow to easily notice this when using
the ``lifting'' functions and to allow to avoid them in a lot of cases,
bringing a substantial gain in efficiency.
\end{enumerate}

\section{Semantics}

Here is an equational specification of bindlib.
To give the semantics, we will use the following convention:
\begin{itemize}
\item variables are structure of type

\verb#'a variable = {id : int; name : string; f : 'a variable -> 'a}#

that are produced only by a function

\verb#new_var : ('a variable -> 'a) -> string -> 'a variable#

which always generates fresh \verb#id#.

\item We will use values written
 $\verb#unbox#_e$ where $e$ is an association list associating to a
 value of type \verb#'a variable# a value of type \verb#'a#.

In fact $e$ has type $\verb#env# = \exists \verb#('a.'a variable * 'a) list#$.

This is not a valid ML type, but it could be coded in ML. However, we
will use a search function \verb#assoc# (searching for variables)
which should have type \verb#'a variable -> env -> 'a#
which is not possible in  ML. However, in our case, this is type safe only because the same value can
not have type \verb#'a variable# and \verb#'b variable# if
$\verb#'a# \neq \verb#'b#$. This is enforced because the type
\verb#'a variable# is abstract.

\item Value of type \verb#ctxt# will be set of strings. We
  consider that we have a function
\verb#fresh : string -> ctxt -> string * ctxt# such that
$\verb#fresh#\,s\,c = s',c'$ where \verb#s'# is not member of $c$,
has the same prefix that $s$ (only the numerical suffix of
$s$ is
changed) and $c'$ is the addition of $s'$ to the set $c$.

\item In the \verb#letvar# construct, when the \verb#as# keyword is
  ommited,
the name of the identifier is used as a \verb#string# for the variable
name (or as a \verb#string array# with a constant value for multiple binding).

\item In the semantics, we also use
\verb#map#, the standard map function on array
(\verb#Array.map#), and
\verb#fold_map : ('a -> 'b -> 'c * 'b) -> 'a array -> 'b -> 'c array * 'b#
which definition follows
\begin{verbatim}
let fold_map f tbl acc =
  let acc = ref acc in
  let fn x =
    let x', acc' = f x !acc in
    acc := acc';
    x'
  in
  let tbl' = Array.map fn tbl in
  tbl', !acc
\end{verbatim}

\end{itemize}

\begin{figure}
\begin{tabular}{rcl}
\verb#unbox# &=& $\verb#unbox#_{\verb#[]#}$\cr
$\verb#unbox#_e \verb#(#\verb#box#\;v\verb#)#$ &=& $v$\cr
$\verb#unbox#_e \verb#(#\verb#apply_box#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)#
\verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#unbox#_e \verb#(#\verb#bind_apply#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)# \verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#in#\;p$ &=& $\verb#let #id \verb# = new_var#\;f\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fresh
  }s\;ctxt\;\hbox{\tt in let }\;id\; \hbox{\tt = new\_var}\;f\;s\;\hbox{\tt in}\;p$} \cr
$\verb#name_of # v $ &=& v\verb#.name# \cr
$\verb#subst# \verb#(#\verb#unbox#_e \verb#(#\verb#bindvar#\;v\;\verb#in# f\verb#)#\verb#)# a$ &=& $\verb#unbox#_{\verb#(#v,a\verb#)#::e} f$\cr
$\verb#unbox#_e \verb#(#\verb#bindbox_of#\;v\verb#)#$ &=& $\verb#try assoc #v\;e \verb# with Not_found -> # v\verb#.f#\;v$ \cr
$\verb#unbox#_e \verb#(^#a_1, \dots, a_n\verb#^)#$ &=& $\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#unbox#_e \verb#[^#a_1; \dots; a_n\verb#^]#$ &=& $\verb#[#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#]#$ \cr
$\verb#unbox#_e \verb#[|^#a_1; \dots; a_n\verb#^|]#$ &=& $\verb#[|#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#|]#$ \cr
$\verb#unbox#_e \verb#(#\verb#Cstr(^#a_1, \dots, a_n\verb#^)#\verb#)#$ &=& $\verb#Cstr#\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#in#\;p$ &=&
  $\verb#let #ids\verb# = map (new_var#\;f\verb#)#\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fold\_map fresh }s\;ctxt\;\hbox{\tt in let }ids\;\hbox{\tt  = map (new\_var}\;f)\;s\;\hbox{\tt in}\;p$} \cr
\end{tabular}
\caption{Equational semantics for bindlib}
\end{figure}
\end{document}

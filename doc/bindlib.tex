\documentclass[11pt]{article}
\usepackage{a4wide}
\usepackage{ocamldoc}

\hfuzz=5pt
\parindent=0pt
\parskip=0.8ex
\title{Bindlib \\ A package for abstract syntax with binder. \\
          version 3.2}
\author{Christophe Raffalli \\
Université de Savoie}



\def\circum{\textasciicircum}
\def\example#1{%
  \def\bverbatim{\begin{verbatim}}%
  \def\inputf{\input{\string#1\string.\expandafter\string\language}}%
  \expandafter\bverbatim\inputf}

\begin{document}

\maketitle

\begin{abstract}
  \verb!bindlib! is a library and a camlp4 syntax extension for the
OCaml language. It proposes a set of tools to manage data structures
with bound and free variables. It includes fast substitution and management 
of variables names including renaming.
\end{abstract}

\tableofcontents

\section{Introduction.}

Data structures with bound and free variables are not so rare in
computer science. For instance, computer programs and mathematical
formulae are data structures using bound and free variables and are needed to write
compilers and computer algebra system.

Representing these variables, implementing the necessary primitives
(substitution
of a variables, renaming to avoid captures, etc.) is not so easy and
often the simple implementation result in poor performance, especially
when substitution is needed.

Bindlib aims at providing a library resulting in both simple and
efficient code. It provides tools to deal with substitution and
renaming.

The version 3.0 of bindlib is simpler to use than the previous ones
because of its camlp4 syntax extension and completely 
rewritten documentation.

This documentation is in two parts : an informal presentation
introducing each concept step by step illustrated with examples. Then,
a more formal presentation in the appendix which includes the syntax
and an equational semantics of the library.

For our examples, we assume basic knowledge of the $\lambda$-calculus
which is the simplest data structure with bound variables (Wikipedia
has a good introduction on this topic). For the second example, we
will give the required mathematical definitions.

\section{Using and installing}

This library only works with ocaml version 3.09.x., 3.10.x and after 

To install the library follow the following steps:
\begin{description}
\item [\tt cp Makefile-3.XX Makefile] copy Makefile-3.09 or Makefile-3.10 to Makefile depending upon your
ocaml version

\item[\tt make checkconfig]:
  check the guessed value of BINDIR and LIBDIR. If it does not suit you,
  edit the Makefile.

\item[\tt make]:
  this compiles the library.

\item[\tt make check]: 
  optional, to test the library.

\item[\tt make install]:
  to install everything.
\end{description}

To use the library, compile your files with one of the following
commands:

\begin{description}
\item[\tt ocamlc -pp camlp4bo -c foo.ml]: to produce \verb#foo.cmo# from
  \verb#foo.ml#, if it uses bindlib.

\item[\tt ocamlc -pp camlp4bop -c foo.ml]: to produce \verb#foo.cmo# from
  \verb#foo.ml#, if it uses both bindlib and stream pattern matching.

\item[\tt ocamlc -pp "camlp4 pa\_bindlib.cmo ..." -c foo.ml]: if you
  want to use bindlib together with your other favorite extension.

\item[] The same options work with \verb#ocamlopt#.

\item[] Finally, link with \verb#bindlib.cma# or \verb#bindlib.cmxa#.
\end{description}

\section{Basic types}

Before considering bound and free variables in data structures, we
should say what a data structure is. For this documentation, we will
consider that a data structure is an ML value (like a list of
integers, a tree, etc.) with no ML function
inside. 

Now, the main type constructor of the bindlib library is:
$$\verb!('a,'b) binder!.$$

This is the type of a data structure of type \verb!'b! with one bound
variable of type \verb!'a!.

For variables, bindlib provide a type 
$$\verb!'a variable!$$ 
for variable in data structure of type \verb!'a!.

With these type constructors, we can define easily the type of
lambda-terms:

\begin{verbatim}
type term = 
  App of term * term         (* application of two terms *)
| Abs of (term, term) binder (* abstraction of a variable in a term *)
| FVar of term variable      (* free variable *) 
\end{verbatim}

\section{How to use a data structure with variables ?}

Now let us start by using data structure with bound and free
variables.
Consider the following function to print lambda-terms:


\begin{verbatim}
let fVar x = FVar(x)

let rec print_term t =
  App(t1,t2) ->
    print_string "("; 
    print_term t1; print_string " "; print_term t2; 
    print_string ")"
| Abs f ->
    match f with bind fVar x in t ->
      print_string "fun "; print_string (name_of x); print_string " ";
      print_term t
| FVar(x) ->
    print_string (name_of x)
\end{verbatim}

The first line creates a function synonymous to the \verb!FVar!
constructor. Then, printing of application is straight forward.

For abstraction, we use one of our camlp4 extension:
\verb!match f with bind fVar x in t! destruct \verb!f! which is an
expression $e$ with one bound variable $v$ (remark: the programmer has
no direct access to $e$ and $v$, this is why we do not use a
typewriter font for them). A new variable \verb!x! is created by
this construct, and \verb!t! denotes $e$ where $v$ is replaced by
\verb!fVar x!. This explains the two last line of the program. Notice
the function \verb!name_of! to get the variable name.

Let us now give an equivalent to the camlp4 syntax extension we
use. The line 
\begin{center}
\verb!match f with bind fVar x in t ->! 
\end{center}
is equivalent to the following three lines:
\begin{center}
\begin{verbatim}
                      let name = binder_name f in
                      letvar fVar x as name in
                      let t = subst f (free_of x) in
\end{verbatim}
\end{center}

These lines use the following functions:
 
\begin{itemize}
\item \verb#binder_name : ('a, 'b) binder -> string# to get the name of
the bound variable.

\item \verb#letvar fVar x as name in# is yet another a camlp4 extension
creating a new variable \verb#x : term variable#. 

\verb#fVar# means that \verb#free_of x# 
evaluates to \verb#fVar x# which evaluates itself to \verb#FVar(x)#

\verb#as name# means that the name of the variable \verb#x# will be
\verb#name#. This means that \verb#name_of x# evaluates to \verb#name#.

This camlp4 syntax extension is equivalent to 
\verb#let x = new_var fVar name in# where

\verb#new_var : ('a variable -> 'a) -> string -> 'a variable# 

(we will see later the interest of the \verb#letvar# camlp4
extension)

\item \verb#free_of : 'a variable -> 'a# has been explained above with
  \verb#letvar#.

\item \verb#subst : ('a, 'b) binder -> 'a -> 'b# to substitute a value
to the bound variable in \verb#f#.
\end{itemize}


n\section{How to construct a data structure with variables ?}

To construct data structure with bound variables, we provide a new type 
\begin{center}
\verb!'a bindbox!  
\end{center}

Which is the type of a data structure of type \verb#'a# under
construction.

In fact this type contructor is a monad. If you do not know what a
monad is just consider this is the notion of morphism associated to
typed programming language. If you do not know what a morphism is, then
just ignore this paragraph !

Let use give some examples:

\begin{verbatim}
let fVar x = FVar(x)

let idt = unbox (Abs(^ bind fVar x in x ^))
let delta = unbox (Abs(^ bind fVar x in App(^x,x^) ^))
\end{verbatim}

Here are the basic idea in the above examples: we use \verb#Abs(^ ... ^)# and
\verb#App(^ ... ^)# to construct value of type \verb#term bindbox#
instead of \verb#term# directly. Then, the camlp4 syntax extension 
\verb#bind fVar x in# allows to construct a value of type 
\verb#(term, term) binder bindbox#. Finally, \verb#unbox# finishes the work and produces a
value of type \verb#term# from a value of type \verb#term bindbox#.

Here is a list with more detailed explanation of the common functions
and camlp4 syntax extensions to construct data structure with bound and
free variables:

\begin{itemize}
\item \verb#unit : 'a -> 'a bindbox# : you use this function when you
  have an object of type \verb#'a# that you want to extend. 

Warning: with \verb#unit t#, you will not be able to bind free
variables in \verb#t#.

\item \verb#(^t^)# : a camlp4 syntax extension for \verb#unit t# (t is
  parsed at the priority \verb#LEVEL ":="#).

\item \verb#(^t1, ... , tn^)# : to construct tuples in the \verb#bindbox#
  type.
If \verb#t1 : 'a1 bindbox#, \dots, \verb#tn : 'an bindbox#, then 
\verb#(^t1, ..., tn^) : ('a1 * ... * 'an) bindbox#

\item \verb#[^t1; ... ; tn^]# to construct lists in the bindbox type.
If \verb#t1 : 'a bindbox#, \dots, \verb#tn : 'a bindbox#, then 
\verb#[^t1; ...; tn^] : 'a list bindbox#

\item \verb#[|^t1; ... ;tn^|]# to construct arrays in the bindbox type.
If \verb#t1 : 'a bindbox#, \dots, \verb#tn : 'a bindbox#, then 
\verb#[|^t1; ...; tn^|] : 'a array bindbox#

\item \verb# ( ^:: ) : 'a bindbox -> 'a list bindbox -> 'a list  bindbox#: 
to construct list cells. Remark: this is a camlp4 extension to have the
same priority as \verb#::#.

\item \verb#Cstr(^t1, ... , tn^)#\label{liftconstr} : to apply a variant constructor 
in the \verb#bindbox#
  type. This also works for polymorphic variant constructors.

Example: if \verb#t1# and \verb#t2# are of type \verb#term bindbox#,
then \verb#App(^t1,t2^)# is also of type \verb#term bindbox#.

More generally, if you have a type constructor \verb#Cstr# with the following typing rule:
$$
\frac{x_1 : t_1  \hspace{1cm} \dots  \hspace{1cm} x_n : t_n}
{\hbox{\tt Cstr(}x_1,\dots,x_n\hbox{\tt)} : u}
$$
Then, you also have
$$
\frac{x_1 : t_1 \hbox{ \tt bindbox} \hspace{1cm} \dots \hspace{1cm} x_n : t_n \hbox{ \tt bindbox}}
{\hbox{Cstr\tt(\circum}x_1,\dots,x_n\hbox{\tt\circum)} : u \hbox{ \tt bindbox}}
$$ 
\item \verb#{^ l1 = t1; ...;  ln = tn ^}# : to construct a structure
  in the bindbox type. 

Example: if one defines the type 
\verb#defi = { name : string;  value : term}#
and if \verb#t : term bindbox#, then 
\verb#{^ name = (^ "foo" ^);  value = t ^} : defi bindbox#.
\end{itemize}

Now one also need the following functions and camlp4 extension to deal
with variables:

\begin{itemize}
\item \verb#bindbox_of : 'a variable -> 'a bindbox# : this is the
  correct (and unique) way to use a variable in order to be able to
  bind it.

\item \verb#bindvar x in t# : this is a camlp4 extension. If 
\verb#x : 'a variable# and \verb#t : 'b bindbox#, then 
\verb#bindvar x in t : ('a, 'b) binder bindbox#.

\item \verb#bind f x in t# : this is a camlp4 extension (the variable
  \verb#x# is bound in \verb#t#) and it is a short cut for:
\begin{verbatim}
letvar f x' in
let x = bindbox_of x' in
bindvar x' in t
\end{verbatim}  

\item \verb#unbox : 'a bindbox -> 'a# : this is the function to
produce the final data-structure. In \verb#unbox t#, all the variables
that were not bound using the \verb#bind# or \verb#bindvar# camlp4
extension will become free variables by calling the function 
\verb#f : 'b variable -> 'b# that you had to give when creating the variable
with the \verb#letvar# or \verb#bind# camlp4 extension.
\end{itemize}


Here is another example, which performs the following transformation on
$\lambda$-term (it marks all the application with a variable):
$$
\begin{array}{rcl}
\hbox{mark}(t) &=& \lambda x.\phi_x(t) \cr
\phi_x(y) &=& y \cr
\phi_x(u\,v) &=& x\,\phi_x(u)\,\phi_x(v) \cr
\phi_x(\lambda y.u) &=& \lambda y.(\phi_x u)
\end{array}
$$

Here is the corresponding code:

\begin{verbatim}
let mark t =
  let rec phi x = function
    FVar(y) -> bindbox_of y
  | App(u,v) -> App(^App(^x,phi x u^),phi x v^)
  | Abs(f) ->
      match f with bind fVar y in f' ->
        Abs(^ bindvar y in phi x f' ^)
  in
  unbox(Abs(^ bind fVar x in phi x t^))
\end{verbatim}

This code is very similar to the mathematical definition.
Here is another example: the computation of the normal form of a term:

\begin{verbatim}
(* weak head normal form *)
let rec whnf = function
  App(t1,t2) as t0 -> (
    match (whnf t1) with
      Abs f -> whnf (subst f t2)
    | t1' -> 
       (* a small optimization here when the term is in whnf *)
       if t1' == t1 then t0 else App(t1', t2))
| t -> t

(* call by name normalisation *)
let norm t = let rec fn t = 
  match whnf t with
    Abs f -> 
      match f with bind fVar x in u ->
      Abs(^ bindvar x in fn u ^)
  | t -> 
      let rec unwind = function
          FVar(x) -> bindbox_of x
        | App(t1,t2) -> App(^unwind t1,fn t2^)
        | t -> assert false
      in unwind t
in unbox (fn t)
\end{verbatim}

This function is very similar to the previous one, with one function
to compute the ``weak head normal form'', which is used in the second
function to compute the full normal form. Understanding this function
is more a question of knowledge of $\lambda$-calculus than a problem of
the library itself.

\section{Naming of variables}

The bindlib library uses \verb#string# for variable names. Names are
considered
as the concatenation of a prefix and a possibly empty suffix. The
suffix is the longest terminal substring of the name composed only of
digits.

Example: in \verb#"toto0"# the suffix is \verb#"0"#.

To choose the initial name of a variable, you use the \verb#"as"#
keyword in

\begin{verbatim}
letvar f x as name in t
\end{verbatim}

This means that \verb#name_of x# will return \verb#name#. However,
when binding \verb#x# using \verb#bindvar x in u#, the suffix of
the name may be changed to avoid name conflict. In 
\verb#letvar f x in t#, the default name for \verb#x# will be
\verb#"x"# (that is the string build from the name of the identifier).

To access the name of variables, bindlib provides the following
functions:

\begin{itemize}
\item \verb#name_of : 'a variable -> string# to access the name of a free
  variable.

\item \verb#binder_name : ('a, 'b) variable -> string# to access the
  name of a bound variable.

\item \verb#match t with bind f x in u -> ...#: if
 \verb#t : ('a, 'b) binder#, then we have \verb#x# of type \verb#'a variable# and
 \verb#name_of x# will return the same value as \verb#binder_name t#.
\end{itemize}

Using bindlib you are sure that bound variables are renamed to avoid
variable conflict. But this is not enough:
\begin{enumerate}
\item Distinct free variables may have the same name. Renaming of free
  variables can not be done automatically because there is no way to
  know the variables that are used in the same ``context''.
\item The \verb#subst# function does not perform renaming. Therefore,
  it is only just after the call to \verb#unbox# that the bound
  variables are named correctly. If you use the result of \verb#unbox#
  and perform substitution then, the naming may become incorrect. 

  This can not be avoided if one want a reasonable complexity for
  substitution.

\item By default, bindlib perform minimal renaming. This means it
  accepts name collision in \verb#fun x -> fun x -> x# that you might prefer printed as
\verb#fun x -> fun x0 -> x0#. 
\end{enumerate}

To solve these problems, bindlib provides an abstract notion of context
 which are ``sets'' of free variables which should have
 distinct names. 
\begin{itemize}
\item\verb#type context# is  an abstract type.
\item\verb#empty_context : context# is the initial empty context.
\item\verb#letvar f x as name for ctxt in ...# The argument of \verb#for# must be an Ocaml
identifier of type \verb#context#. The name given with \verb#as name#
may be changed (only the suffix is changed) into a name not already in
\verb#ctxt#. Then, the identifier  \verb#ctxt# is rebound, under the
scope of \verb#letvar#, to an extended context containing the new variable name.

This construct can also
be used with the \verb#bind f x as name for ctxt in ...# camlp4 extension.
\end{itemize}

This fixes point (1). For the two other points, there are two solutions,
depending if you prefer minimal renaming or the so called Barendregt
convention (no bound variable should have the same name than a free
variable, even is the later does not occur in the scope of the
former).

If you want to follow Barendregt convention, this is easy, your
printing functions should use a \verb#context# as in:

\begin{verbatim}
let rec print_term ctxt = function
  App(t1,t2) ->
    print_string "(";
    print_term ctxt t1;
    print_string " ";
    print_term ctxt t2;
    print_string ")"
| Abs f ->
    match f with bind fVar x for ctxt in t ->
      print_string "fun ";
      print_string (name_of x);
      print_string " ";
      print_term ctxt t
| FVar(v) ->
    print_string (name_of v)
\end{verbatim}

If you prefer minimal renaming (which is required when you really want
to refer to names of bound variables), you have nothing to do if you are
certain that no substitution have been performed. Otherwise, you need
what I call a ``lifting'' function to copy the data structure before
printing as in the following example:

\begin{verbatim}
let rec lift_term = function
    FVar(y) -> bindbox_of y
  | App(u,v) -> App(^lift_term u, lift_term v^)
  | Abs(f) ->
      match f with bind fVar x in u ->
        Abs(^ bindvar x in lift_term u ^)

let print_term t =
  let rec fn = function
      App(t1,t2) ->
        print_string "(";
        fn t1;
        print_string " ";
        fn t2;
        print_string ")"
    | Abs f ->
        match f with bind fVar x in t ->
          print_string "fun ";
          print_string (name_of x);
          print_string " ";
          fn t
    | FVar(v) ->
        print_string (name_of v)
  in
  fn (unbox (lift_term t))
\end{verbatim}

\section{A more complete example and advanced features}

This section covers advanced feature of the library. The reader is
advised to read, practise and understand the previous section before
reading this.

We will consider second order predicate logic. 
We chose this example, because the definition of second-order
substitution is non trivial ... and this is a very good example for
the power of \verb#bindlib#.

Here is the mathematical definition of terms and formulas, and the
corresponding definition using \verb#bindlib#:

\newtheorem{definition}{definition}\
\begin{definition}[Syntax of second order logic]\rm
We assume a signature 
$$\Sigma = \{(f,1), (g,2), (a,0), \dots\}$$ with various
constants and function symbols of
various arity. An infinite set of first-order variables (written
$x,y,z\dots$) and for each natural number $n$ an infinite set of 
second-order variables of arity $n$ (written $X,Y,Z,\dots$).

Terms are defined by
\begin{itemize}
\item $x$ is a term if it is a first order variable
\item $f(t_1,\dots,t_n)$ is a term if $f$ is a function symbol of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\end{itemize}

Formulas are defined by
\begin{itemize}
\item $X(t_1,\dots,t_n)$ is a formula if $X$ is a second order variable of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\item $A \to B$ is a formula if $A$ and $B$ are formulas.
\item $\forall x\,A$ is a formula with $x$ bound if $A$ is a formula
and $x$ is a first-order variable.
\item $\forall X\,A$ is a formula with $X$ bound if $A$ is a formula
and $X$ is a second-order variable.
\end{itemize}
\end{definition}

\begin{verbatim}
(* a structure to store the information about a function symbol *)
type symbol = {name : string; arity : int }

(* the type of first order term *)
type term = 
    Fun of symbol * term array
  | TermVar of term variable

(* the type of second order formula *)
type form =
  Imply of form * form
| Forall1 of (term, form) binder         (* fitst order quantifier *)
| Forall2 of int * (pred, form) binder   (* second order quantifier *)
                                         (* the int in the arity *)
| FormVar of pred variable * term array  (* a predicate variables and *)
                                         (* its arguments *)

and pred = (term, form) mbinder          (* a predicate is a binder ! *)

let lam1 x = TermVar(x)

let lam2 n x = 
  unbox (bind lam1 args(n) in FormVar(^ (^x^), lift_array args^))
\end{verbatim}

Let us review these definitions:
\begin{itemize}
\item \verb#pred = (term, form) mbinder#: this is the type of an object
of type \verb#form# with an array of bound variables. We use this to
represent predicates, that is formula with $n$ parameters.

\item \verb#Forall2 of int * (pred, form) binder#: for second order
quantification, we bind a variable of arity $n$. The arity is the
first argument of the constructor. For the second argument, 
\verb#(pred, form) binder#, we mean that we bind a ``predicate''
variable. This variable is
itself a \verb#mbinder#, this is why it is a ``second-order'' variable.

\item \verb#FormVar of pred variable * term array#: as usual
for any free variable, we have to store 
the variable itself of type \verb#pred variable#. 
But here, we should also store the terms which
are the arguments of the second-order predicate variable.

\item \verb#let lam1 x = TermVar(x)#: we introduce the
function to construct first-order binder. Every time we will want to
construct a first-order quantification, we will write 

\verb#Forall1(^ bind lam1 x in ... ^)#

\item \verb#bind lam1 args(n) in ...# : this binds an array of
  \verb#term variable# of arity \verb#n#. The typing rule of this camlp4
extension is:
$$
\frac{
\begin{array}{l}\Gamma, \hbox{\tt x :$\!$ 'a array bindbox} \vdash \hbox{\tt e
:$\!$ 'b bindbox}
\cr \Gamma \vdash \hbox{\tt f :$\!$ 'a variable
-> 'a}
\cr \Gamma \vdash \hbox{\tt n : int}
\end{array}}
{\Gamma \vdash \hbox{\tt bind f x(n) in e :$\!$ ('a, 'b) mbinder bindbox}}
$$

\item \verb#lift_array# : this is a function of type
  \verb#'a bindbox array -> 'a array binxbox#, which is often used when
  binding array of variables.

\item \verb#let lam2 n x =#\\
\verb#  unbox (bind lam1 args(n) in FormVar(^ (^x^), lift_array args^))#:
we introduce the
function to construct second-order binder. It is a bit complex, but
typing gives very little choice: we have \verb#arity : int#,
and \verb#x : pred variable#. And we need an
object of type \verb#pred#. We have:

\begin{itemize}
\item \verb#x : pred variable# and therefore,  
\verb#(^x^) : pred variable bindbox#   
\item \verb#args : term bindbox array# gives
\verb#lift_array args : term array bindbox#
\item all this gives
\verb#FormVar(^ ... ^) : form bindbox#, using the rule given page
\pageref{liftconstr} for lifted constructor.
\item
\verb#bind lam1 args(arity) in FormVar(^ ... ^) : pred bindbox#.
\item Finally, \verb#unbox (bind lam1 args(arity) in FormVar(^ ... ^)) : pred#
\end{itemize}

Like for first-order variables, every time we will want to
construct a second-order quantification of arity \verb#n#, we will write 
\verb#Forall2(^ unit n, bind lam2 x(n) in ... ^)#.
\end{itemize}

Now, we write the printing function for terms and formulas:

\begin{verbatim}
let rec print_term = function
    Fun(sy, ta) ->
      print_string sy.name;
      print_string "(";
      for i = 0 to sy.arity - 1 do
        print_term ta.(i);
        print_string (if i < sy.arity - 1 then "," else ")")
      done
  | TermVar(var) ->
      print_string (name_of var)

let rec print_form lvl = function
    Imply(f1, f2) ->
      if lvl > 0 then print_string "(";
      print_form 1 f1; print_string " => "; print_form lvl f2;
      if lvl > 0 then print_string ")";
  | Forall1 f ->
      match f with bind lam1 t  in g ->
        print_string "Forall1 ";
        print_string (name_of t);
        print_string " ";
        print_form 1 g
  | Forall2 (arity, f) ->
      match f with bind (lam2 arity) x in g ->
      print_string "Forall2 ";
      print_string (name_of x);
      print_string " ";
      print_form 1 g
  | FormVar(var,args) ->
      print_string (name_of var);
      print_string "(";
      let arity = Array.length args in
      for i = 0 to arity - 1 do
        print_term args.(i);
        print_string (if i < arity - 1 then "," else ")")
      done
\end{verbatim}

We also write the equality test which is similar:
\begin{verbatim}
let rec equal_term t t' = match t, t' with
    TermVar(x), TermVar(x') -> x == x'
  | Fun(sy,ta), Fun(sy',ta') when sy = sy' ->
      let r = ref true in
      for i = 0 to sy.arity - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false

let rec equal_form f f' = match f, f' with
    Imply(f,g), Imply(f',g') -> 
      equal_form f f' && equal_form g g'
  | Forall1(f), Forall1(f') ->
      match f with bind lam1 t in g ->
      equal_form g (subst f' (free_of t))
  | Forall2(arity,f), Forall2(arity',f') ->
      arity = arity' &&
      match f with bind (lam2 arity) x in g ->
      equal_form g (subst f' (free_of x))
  | FormVar(x,ta), FormVar(x',ta') ->
      x == x' && 
      let r = ref true in
      for i = 0 to Array.length ta - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false
\end{verbatim}

One remark here: we do not use the variables names for comparison
(because it is slower and for another reason that we will see later),
but instead we use physical equality on the free variables we create to substitute to
bound variables.
It is possible to use structural equality because a
variable is a structure whose first field is a unique identifier. But
you should be aware that one of the field of this structure is an ML
closure (the function of type \verb#'a variable -> 'a# given when
creating the variable).
 
Now, we give the lifting functions (already mentioned about naming): very often, we have
an object \verb#o# of type \verb#t bindbox# that we want to
read/match. Therefore, we will use \verb#unbox#. 
But then, we will want to reuse the subterms of \verb#o# with
type  \verb#t bindbox# to continue the construction of an object of
type \verb#t# with some bound variables. For this, we need this kind
of copying functions:

\begin{verbatim}
let rec lift_term = function
    TermVar(x) -> bindbox_of x
  | Fun(sy,ta) -> Fun(^ (^sy^), lift_array (Array.map lift_term ta) ^)

let rec lift_form = function
    Imply(f1,f2) -> Imply(^ lift_form f1, lift_form f2 ^)
  | Forall1 f ->
      match f with bind lam1 t in g ->
       Forall1(^ bindvar t in lift_form g ^)
  | Forall2(arity,f) ->
      match f with bind (lam2 arity) x in g ->
      Forall2(^ (^arity^), bindvar x in lift_form g ^)
  | FormVar(x,args) ->
      mbind_apply (bindbox_of x) (lift_array (Array.map lift_term args))
\end{verbatim}

The functions
\verb#bind_apply : ('a -> 'b) binder bindbox -> 'a bindbox -> 'b bindbox# and 
\verb#mbind_apply  ('a -> 'b) mbinder bindbox -> 'a bindbox array -> 'b bindbox# 
for multiple binder are
used to apply to its arguments a variable representing a binder.

Now we define proofs (for natural deduction):
\begin{verbatim}
type proof =
    Imply_intro of form * (proof,proof) binder
  | Imply_elim of proof * proof
  | Forall1_intro of (term, proof) binder
  | Forall1_elim of proof * term
  | Forall2_intro of int * (pred, proof) binder
  | Forall2_elim of proof * pred
  | Axiom of form * proof variable

let assume f x = Axiom(f,x)
\end{verbatim}

We remark that all introduction rules are binder and the
implication introduction rule binds a proof inside a proof.
For the function \verb#assume# constructing the variables of type
\verb#proof#, we also store the formula that it ``assumes'' when we do
the introduction of an implication.

Now, we give a simple function to print goals (or sequent), that is a
list of named hypotheses, represented by proof variables, and a
conclusion. We need to copy the hypotheses because they result from a
substitution. This is not the case for the conclusion of the sequent
which is passed to \verb#print_goal# just after the call to \verb#unbox#.
\begin{verbatim}
let print_goal hyps concl = 
  List.iter (
  function
      Axiom(f, v) ->
        print_string (name_of v); print_string ":="; 
        print_form 0 (unbox (lift_form f)); print_newline ()
    | _ ->
        failwith ("not an axiom")) hyps;
  print_string "  |- "; print_form 0 concl; print_newline ()
\end{verbatim}

Now the main function, that checks if a proof is correct. The first
function builds the formula which is proved by a proof, or raise the
exception \verb#Bad_proof# if the proof is incorrect.

The second function calls the first one and checks if the produced
formula is equal to a given formula.

Moreover, to illustrate the problem of variables names, we print the
goal which is obtained after each rule.

Here is the code that we will explain bellow:
\begin{verbatim}
exception Bad_proof of string

let type_infer p = 
  let ctxt = empty_context in
  let rec fn hyps ctxt p = 
    let r = match p with 
      Imply_intro(f,p) ->
        match p with bind (assume f) ax for ctxt in p' ->
        Imply(^ lift_form f, fn (ax::hyps) ctxt p' ^)
    | Imply_elim(p1, p2) ->
        begin
          let f1' = unbox (fn hyps ctxt p2) in
          match unbox (fn hyps ctxt p1) with 
            Imply(f1,f2) when equal_form f1 f1' -> lift_form f2
          | Imply(f1,f2) ->
              print_form 0 f1; print_string "<>"; print_form 0 f1';
              print_newline ();
              raise (Bad_proof("Imply"))
          | _ ->
              raise (Bad_proof("Imply"))
        end
    | Forall1_intro(p) ->
        match p with bind lam1 t for ctxt in p' ->
        Forall1(^ bindvar t in  fn hyps ctxt p'^)
    | Forall1_elim(p,t) ->
        begin
          match unbox (fn hyps ctxt p) with
            Forall1(f) -> lift_form (subst f t) 
          | _ -> raise (Bad_proof("Forall1"))
        end
    | Forall2_intro(arity, f) ->
        match f with bind (lam2 arity) x for ctxt in p' ->
        Forall2(^ (^arity^),  bindvar x in fn hyps ctxt p' ^)
    | Forall2_elim(p,pred) ->
        begin
          match unbox (fn hyps ctxt p) with
n            Forall2(arity, f) when arity = mbinder_arity pred ->
              lift_form (subst f pred) 
          | _ -> raise (Bad_proof("Forall2"))
        end
    | Axiom(f,_) ->
        lift_form f
    in
    print_goal (List.map free_of hyps) (unbox r); print_newline ();
    r
  in
  unbox (fn [] ctxt p)
        
let type_check p f =
  if not (equal_form (type_infer p) f) then raise (Bad_proof "conclusion")
\end{verbatim}
 
There are two important things to comment in these programs: 
\begin{enumerate}
\item We care about variable names using a context for the free
  variables and the \verb#lift_form# function for the bound ones as explained
  before. 

\item The second important point is the use of \verb#unbox# together
with the \verb#lift_form# function to type-check the elimination rules.

We must use \verb#unbox# to match the formula coming from the
type-checking of the principal premise of the rule. Then, one
sub-formula of the matched formula must be used and we have to use
\verb#lift_form# for that.
Important remark: because of the use of \verb#lift_term# and
\verb#lift_form# functions, this algorithm is quadratic (at least), because
it calls \verb#lift_term# and \verb#lift_form# which are linear at
each elimination rule. As an exercise, the reader could rewrite the
\verb#type_infer# function, using a stack, to avoid this.

It is in fact a general problem when writing programs using bound
variables, we have often to make copy of objects (to adjust DeBruijn
indices, to rename variables, to ``relift'' them). And this is
important that \verb#bindlib# allow to easily notice this when using
the ``lifting'' functions and to allow to avoid them in a lot of cases,
bringing a substantial gain in efficiency.
\end{enumerate}

\appendix

\input{bindlib.mli.tex} 

\subsection{Syntactic extension of the language for bindlib}

We describe here the syntactic extension provided by
\verb#pa_bindlib.cmo#.

{\begin{tabular}{rcl}
\it expr &::=& ... \cr
     &$|$& \verb#(^# \it expr \verb#^)# \cr
     &$|$& \verb#(^# \it expr\verb#,# expr {\verb#,# expr} \verb#^)# \cr
     &$|$& \verb#[^ ^]# \cr
     &$|$& \verb#[^# \it expr  {\verb#;# expr} \verb#^]# \cr
     &$|$& \verb#[|^ ^|]# \cr
     &$|$& \verb#[|^# \it expr  {\verb#;# expr} \verb#^|]# \cr
     &$|$& {\it constr}\verb#(^# \it expr \verb#^)# \cr
     &$|$& {\it constr}\verb#(^# \it expr\verb#,# expr {\verb#,# expr} \verb#^)# \cr
     &$|$& \verb#{^# \it field \verb#=# expr  \{\verb#;# field \verb#=# expr\} \verb#^}# \cr
     &$|$& \verb#{^# \it expr \verb#with# field \verb#=# expr  \{\verb#;# field \verb#=# expr\} \verb#^}# \cr
     &$|$& \verb#letvar# {\it expr lowercase-ident\/}[\verb#(# {\it
       expr} \verb#)#] [\verb#as# {\it expr}]
         [\verb#for# {\it lowercase-ident}] \verb#in#  \it expr \cr
     &$|$& \verb#bindvar#  {\it lowercase-ident\/}[\verb#()#]
     \verb#in#  \it expr \cr
     &$|$& \verb#bind# {\it expr lowercase-ident\/}[\verb#(# {\it
       expr} \verb#)#] [\verb#as# {\it expr}]
         [\verb#for# {\it lowercase-ident}] \verb#in#  \it expr \cr
     &$|$& \verb#match# {\it expr}  \verb#with bind# {\it expr lowercase-ident\/}[\verb#(# 
       {\it lowercase-ident\/} \verb#)#] \cr&& \hspace{2em}[\verb#as# {\it expr}]
         [\verb#for# {\it lowercase-ident}] \verb#in#  {\it
           lowercase-ident} \verb#->#\it expr \cr
     &$|$& \it expr \verb#^^# expr \cr
     &$|$& \it expr \verb#^|^# expr \cr
    \cr
\end{tabular}}

Remarks and comment:
\begin{itemize}
\item \verb#(^e^)# is equivalent to \verb#unit e#
\item In \verb#letvar# and \verb#bind#, the first {\it expr} is parser
  at priority level ``simple'' and therefore it should be
  parenthesised if it is not an identifier.
\item in \verb#match ... bind#, the [\verb#as# {\it expr}] option is
  not a pattern to hold the name of the bound variable, but a string you
  can give to rename the variable.
\item \verb#e ^^ e'# is equivalent to \verb#bind_apply e e'# and it is
  left associative and 
  parsed at the priority level of application. This is why it is a
  syntactic extension and not an infix operator.
\item \verb#e ^|^ e'# is equivalent to \verb#mbind_apply e e'# and it is
  left associative and
  parsed at the priority level of application.
\end{itemize}

\input{nvbindlib.mli.tex}

\subsection{Syntactic extension of the language for nvbindlib}

The syntactic extension provided by
\verb#pa_nvbindlib.cmo# are the same as for bindlib, except that the [\verb#as# {\it
  expr}] and
         [\verb#for# {\it lowercase-ident}] options dealing with
         variables are not allowed.

\section{Semantics}

Here is an equational specification of bindlib. 
To give the semantics, we will use the following convention:
\begin{itemize}
\item variables are structure of type 

\verb#'a variable = {id : int; name : string; f : 'a variable -> 'a}#

that are produced only by a function 

\verb#new_var : ('a variable -> 'a) -> string -> 'a variable#

which always generates fresh \verb#id#.

\item We will use values written  
 $\verb#unbox#_e$ where $e$ is an association list associating to a
 value of type \verb#'a variable# a value of type \verb#'a#.

In fact $e$ has type $\verb#env# = \exists \verb#'a (('a variable * 'a) list)#$.

This is not a valid ML type, but it could be coded in ML. However, we
will use a search function \verb#assoc# (searching for variables)  which should have type 
$$\verb#'a variable -> env -> 'a#$$

which is not possible in  ML. However, in our case, this is type safe only because the same value can
not have type \verb#'a variable# and \verb#'b variable# if
$\verb#'a# \neq \verb#'b#$. This is enforced when the type 
\verb#'a variable# is abstract.

\item Value of type \verb#context# will be set of strings. We
  consider that we have a function
\verb#fresh : string -> context -> string * context# such that
$\verb#fresh#\,s\,c = s',c'$ where \verb#s'# is not member of $c$,
has the same prefix that $s$ (only the numerical suffix of
$s$ is
changed) and $c'$ is the addition of $s'$ to the set $c$.

\item In the \verb#letvar# construct, when the \verb#as# keyword is
  ommited,
the name of the identifier is used as a \verb#string# for the variable
name (or as a \verb#string array# with a constant value for multiple binding).

\item In the semantics, we also use 
\verb#map#, the standard map function on array
(\verb#Array.map#), and 
\verb#fold_map : ('a -> 'b -> 'c * 'b) -> 'a array -> 'b -> 'c array * 'b#
which definition follows
\begin{verbatim}
let fold_map f tbl acc =
  let acc = ref acc in
  let fn x = 
    let x', acc' = f x !acc in
    acc := acc';
    x'
  in
  let tbl' = Array.map fn tbl in
  tbl', !acc
\end{verbatim}

\end{itemize}

\begin{figure}
\begin{tabular}{rcl}
\verb#unbox# &=& $\verb#unbox#_{\verb#[]#}$\cr
$\verb#unbox#_e \verb#(#\verb#unit#\;v\verb#)#$ &=& $v$\cr
$\verb#unbox#_e \verb#(#\verb#apply#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)#
\verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#unbox#_e \verb#(#\verb#bind_apply#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)# \verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#in#\;p$ &=& $\verb#let #id \verb# = new_var#\;f\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fresh
  }s\;ctxt\;\hbox{\tt in let }\;id\; \hbox{\tt = new\_var}\;f\;s\;\hbox{\tt in}\;p$} \cr
$\verb#name_of # v $ &=& v\verb#.name# \cr
$\verb#subst# \verb#(#\verb#unbox#_e \verb#(#\verb#bindvar#\;v\;\verb#in# f\verb#)#\verb#)# a$ &=& $\verb#unbox#_{\verb#(#v,a\verb#)#::e} f$\cr  
$\verb#unbox#_e \verb#(#\verb#bindbox_of#\;v\verb#)#$ &=& $\verb#try assoc #v\;e \verb# with Not_found -> # v\verb#.f#\;v$ \cr
$\verb#unbox#_e \verb#(^#a_1, \dots, a_n\verb#^)#$ &=& $\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#unbox#_e \verb#[^#a_1; \dots; a_n\verb#^]#$ &=& $\verb#[#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#]#$ \cr
$\verb#unbox#_e \verb#[|^#a_1; \dots; a_n\verb#^|]#$ &=& $\verb#[|#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#|]#$ \cr
$\verb#unbox#_e \verb#(#\verb#Cstr(^#a_1, \dots, a_n\verb#^)#\verb#)#$ &=& $\verb#Cstr#\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#in#\;p$ &=& 
  $\verb#let #ids\verb# = map (new_var#\;f\verb#)#\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fold\_map fresh }s\;ctxt\;\hbox{\tt in let }ids\;\hbox{\tt  = map (new\_var}\;f)\;s\;\hbox{\tt in}\;p$} \cr
\end{tabular}
\caption{Equational semantics for bindlib}
\end{figure}
\end{document}

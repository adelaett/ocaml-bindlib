<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bindlib (bindlib.Bindlib)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">bindlib</a> &#x00BB; Bindlib</nav><h1>Module <code>Bindlib</code></h1><p>The <code>Bindlib</code> library provides support for free and bound variables in the OCaml language. The main application is the construction of abstract types containing a binding structure (e.g., abstract syntax trees).</p><dl><dt>author</dt><dd>Christophe Raffalli</dd></dl><dl><dt>author</dt><dd>Rodolphe Lepigre</dd></dl><dl><dt>version</dt><dd>5.0</dd></dl><nav class="toc"><ul><li><a href="#variables,-binders-and-substitution">Variables, binders and substitution</a></li><li><a href="#constructing-terms-and-binders-in-the-binding-box">Constructing terms and binders in the binding box</a></li><li><a href="#more-binding-box-manipulation-functions">More binding box manipulation functions</a></li><li><a href="#attributes-of-variables-and-utilities">Attributes of variables and utilities</a></li><li><a href="#attributes-of-binders-and-utilities">Attributes of binders and utilities</a></li><li><a href="#attributes-of-binding-boxes-and-utilities">Attributes of binding boxes and utilities</a></li><li><a href="#working-in-a-context">Working in a context</a></li><li><a href="#unsafe,-advanced-features">Unsafe, advanced features</a></li></ul></nav></header><section><header><h3 id="variables,-binders-and-substitution"><a href="#variables,-binders-and-substitution" class="anchor"></a>Variables, binders and substitution</h3></header><aside><p>The <code>Bindlib</code> library provides two type constructors for building abstract syntax trees: <code>'a var</code> and <code>('a,'b) binder</code>. Intuitively, <code>'a var</code> will be a representation for a free variable of type <code>'a</code>, and <code>('a,'b) binder</code> a representation for a term of type <code>'b</code> depending on a variable (or value) of type <code>'a</code> (type <code>('a,'b) binder</code> can be seen as <code>'a -&gt; 'b</code>). Note that types <code>'a mvar</code> and <code>('a,'b) mbinder</code> are provided for handling arrays of variables.</p></aside><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> <span>'a var</span></code></dt><dd><p>Type of a free variable of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-mvar"><a href="#type-mvar" class="anchor"></a><code><span class="keyword">type</span> <span>'a mvar</span></code><code> = <span><span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> array</span></code></dt><dd><p>Type of an array of variables of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-binder"><a href="#type-binder" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) binder</span></code></dt><dd><p>Type of a binder for an element of type <code>'a</code> into an element of type <code>'b</code>. In terms of higher order abstract syntax, it can be seen as <code>'a -&gt; 'b</code>.</p></dd></dl><dl><dt class="spec type" id="type-mbinder"><a href="#type-mbinder" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) mbinder</span></code></dt><dd><p>Type of a binder for an array of elements of type <code>'a</code> into an element of type <code>'b</code>.</p></dd></dl><aside><p>As an example, we give bellow the definition of a simple representation of the terms of the lambda-calculus.</p><pre><code class="ml">type term =
  | Var of term var
  | Abs of (term, term) binder
  | App of term * term </code></pre></aside><dl><dt class="spec value" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span class="keyword">val</span> subst : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>subst b v</code> substitutes the variable bound by <code>b</code> with the value <code>v</code>. This is a very efficient operation.</p></dd></dl><dl><dt class="spec value" id="val-msubst"><a href="#val-msubst" class="anchor"></a><code><span class="keyword">val</span> msubst : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>msubst b vs</code> substitutes the variables bound by <code>b</code> with the values <code>vs</code>. This is a very efficient operation. Note that the length of the <code>vs</code> array should match the arity of the multiple binder <code>b</code> (it can be obtained with <code>mbinder_arity</code>). If that is not the case, the exception <code>Invalid_argument
    &quot;Bad arity in msubst&quot;</code> is raised.</p></dd></dl><aside><p>Comming back to our lambda-calculus example, we can define the evaluation of a lambda-term as a simple recursive function using <code>subst</code>.</p><pre><code class="ml">let rec eval : term -&gt; term = fun t -&gt;
  match t with
  | App(f,a) -&gt;
      begin
        match eval f with
        | Abs(b) -&gt; eval (subst b a)
        | _      -&gt; t
      end
  | _        -&gt; t </code></pre></aside><dl><dt class="spec value" id="val-new_var"><a href="#val-new_var" class="anchor"></a><code><span class="keyword">val</span> new_var : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span></code></dt><dd><p><code>new_var mkfree name</code> creates a new variable using a function <code>mkfree</code> and a <code>name</code>. The <code>mkfree</code> function is used to inject variables in the type of the corresponding elements. It is a form of syntactic wrapper. Note that a variable name is understood as a couple of a prefix string, and a possible natural number suffix (the longest suffix of <code>name</code> formed of digits). For example, the variable name <code>&quot;xzy&quot;</code> will have no suffix, and <code>&quot;xyz12&quot;</code> will have the prefix <code>&quot;xyz&quot;</code> and the suffix <code>12</code>. Note that the name <code>&quot;xyz007&quot;</code> and <code>&quot;xyz7&quot;</code> are considered the same, and are both shown as the latter by the <code>name_of</code> function.</p></dd></dl><dl><dt class="spec value" id="val-new_mvar"><a href="#val-new_mvar" class="anchor"></a><code><span class="keyword">val</span> new_mvar : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>string array</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span></code></dt><dd><p><code>new_mvar mkfree names</code> creates a new array of variables using a function <code>mkfree</code> (see <code>new_var</code>) and a <code>name</code>.</p></dd></dl><aside><p>Following on our example of the lambda-calculus, the <code>mkfree</code> function for variables of type <code>term var</code> could be defined as follows.</p><pre><code class="ml">let mkfree : term var -&gt; term = fun x -&gt; Var(x) </code></pre></aside><dl><dt class="spec value" id="val-name_of"><a href="#val-name_of" class="anchor"></a><code><span class="keyword">val</span> name_of : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>name_of x</code> returns a printable name for variable <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-names_of"><a href="#val-names_of" class="anchor"></a><code><span class="keyword">val</span> names_of : <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> <span>&#45;&gt;</span> <span>string array</span></code></dt><dd><p><code>names_of xs</code> returns printable names for the variables of <code>xs</code>.</p></dd></dl><dl><dt class="spec value" id="val-unbind"><a href="#val-unbind" class="anchor"></a><code><span class="keyword">val</span> unbind : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> * <span class="type-var">'b</span></code></dt><dd><p><code>unbind b</code> substitutes the binder <code>b</code> using a fresh variable. The variable and the result of the substitution are returned. Note that the name of the fresh variable is based on that of the binder. The <code>mkfree</code> function used to create the fresh variable is that of the variable that was bound by <code>b</code> at its construction (see <code>new_var</code> and <code>bind_var</code>).</p></dd></dl><dl><dt class="spec value" id="val-unbind2"><a href="#val-unbind2" class="anchor"></a><code><span class="keyword">val</span> unbind2 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> * <span class="type-var">'b</span> * <span class="type-var">'c</span></code></dt><dd><p><code>unbind2 f g</code> is similar to <code>unbind f</code>, but it substitutes two binders <code>f</code> and <code>g</code> at once using the same fresh variable. The name of the variable is based on that of the binder <code>f</code>. Similarly, the <code>mkfree</code> syntactic wrapper that is used for the fresh variable is the one that was given for creating the variable that was bound to construct <code>f</code> (see <code>bind_var</code> and <code>new_var</code> for details on this process). In particular, the use of <code>unbind2</code> may lead to unexpected results if the binders <code>f</code> and <code>g</code> were not built using free variables created with the same <code>mkfree</code>.</p></dd></dl><dl><dt class="spec value" id="val-eq_binder"><a href="#val-eq_binder" class="anchor"></a><code><span class="keyword">val</span> eq_binder : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eq_binder eq f g</code> tests the equality between <code>f</code> and <code>g</code>. The binders are first substituted with the same fresh variable (using <code>unbind2</code>), and <code>eq</code> is called on the resulting values. Note that <code>eq_binder</code> may not have the expected result if <code>f</code> and <code>g</code> were not built by binding variables with an identical <code>mkfree</code> syntactic wrapper.</p></dd></dl><dl><dt class="spec value" id="val-unmbind"><a href="#val-unmbind" class="anchor"></a><code><span class="keyword">val</span> unmbind : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> * <span class="type-var">'b</span></code></dt><dd><p><code>unmbind b</code> substitutes the multiple binder <code>b</code> with fresh variables. This function is analogous to <code>unbind</code> for binders. Note that the names used to create the fresh variables are based on those of the multiple binder. The syntactic wrapper (of <code>mkfree</code>) that is used to build the variables is the one that was given when creating the multiple variables that were bound in <code>b</code> (see <code>new_mvar</code> and <code>bind_mvar</code>).</p></dd></dl><dl><dt class="spec value" id="val-unmbind2"><a href="#val-unmbind2" class="anchor"></a><code><span class="keyword">val</span> unmbind2 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> * <span class="type-var">'b</span> * <span class="type-var">'c</span></code></dt><dd><p><code>unmbind2 f g</code> is similar to <code>unmbind f</code>, but it substitutes two multiple binder <code>f</code> and <code>g</code> at once, using the same fresh variables. Note that the two binders must have the same arity. This function may have an unexpected results in some cases (see the documentation of <code>unbind2</code>).</p></dd></dl><dl><dt class="spec value" id="val-eq_mbinder"><a href="#val-eq_mbinder" class="anchor"></a><code><span class="keyword">val</span> eq_mbinder : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eq_mbinder eq f g</code> tests the equality of the two multiple binders <code>f</code> and <code>g</code>. They are substituted with the same fresh variables (using <code>unmbind2</code>) and <code>eq</code> is called on the resulting values. This function may not have the expected result in some cases, for reasons explained in the documentation of <code>eq_binder</code>. It is safe to use this function on multiple binders with a different arity (they are considered different).</p></dd></dl><aside><p>An usual use of <code>unbind</code> is the writing of pretty-printing functions. The function given bellow transforms a lambda-term into a <code>string</code>. Note that the <code>name_of</code> function is used for variables.</p><pre><code class="ml">let rec to_string : term -&gt; string = fun t -&gt;
  match t with
  | Var(x)   -&gt; name_of x
  | Abs(b)   -&gt; let (x,t) = unbind b in
                &quot;λ&quot; ^ name_of x ^ &quot;.&quot; ^ to_string t
  | App(t,u) -&gt; &quot;(&quot; ^ to_string t ^ &quot;) &quot; ^ to_string u </code></pre></aside></section><section><header><h3 id="constructing-terms-and-binders-in-the-binding-box"><a href="#constructing-terms-and-binders-in-the-binding-box" class="anchor"></a>Constructing terms and binders in the binding box</h3></header><aside><p>To obtain fast substitutions, a price must be paid at the construction of terms. Indeed, binders (i.e., element of type <code>('a,'b) binder</code>) cannot be defined directly. Instead, they are put together in the type <code>'a box</code>. It correspond to a term of type <code>'a</code> which free variables may be bound in the future.</p></aside><dl><dt class="spec type" id="type-box"><a href="#type-box" class="anchor"></a><code><span class="keyword">type</span> <span>+'a box</span></code></dt><dd><p>Type of a term of type <code>'a</code> under construction. Using this representation, the free variable of the term can be bound easily.</p></dd></dl><dl><dt class="spec value" id="val-box_var"><a href="#val-box_var" class="anchor"></a><code><span class="keyword">val</span> box_var : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_var x</code> builds a <code>'a box</code> from the <code>'a var</code> <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-box"><a href="#val-box" class="anchor"></a><code><span class="keyword">val</span> box : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box e</code> injects the value <code>e</code> into the <code>'a box</code> type, assuming that it is closed. Thus, if <code>e</code> contains variables, then they will not be considered free. This means that no variable of <code>e</code> will be available for binding.</p></dd></dl><dl><dt class="spec value" id="val-apply_box"><a href="#val-apply_box" class="anchor"></a><code><span class="keyword">val</span> apply_box : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>apply_box bf ba</code> applies the boxed function <code>bf</code> to a boxed argument <code>ba</code> inside the <code>box</code> type. This function is used to build new expressions by applying a function with free variables to an argument with free variables (the <code>'a box</code> type is an applicative functor which application operator is <code>apply_box</code>, and which unit is <code>box</code>).</p></dd></dl><dl><dt class="spec value" id="val-box_apply"><a href="#val-box_apply" class="anchor"></a><code><span class="keyword">val</span> box_apply : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_apply f ba</code> applies the function <code>f</code> to a boxed argument <code>ba</code>. It is equivalent to <code>apply_box (box f) ba</code>, but is more efficient.</p></dd></dl><dl><dt class="spec value" id="val-box_apply2"><a href="#val-box_apply2" class="anchor"></a><code><span class="keyword">val</span> box_apply2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_apply2 f ba bb</code> applies the function <code>f</code> to two boxed arguments <code>ba</code> and <code>bb</code>. It is equivalent to <code>apply_box (apply_box (box f) ba) bb</code> but it is more efficient.</p></dd></dl><dl><dt class="spec value" id="val-bind_var"><a href="#val-bind_var" class="anchor"></a><code><span class="keyword">val</span> bind_var : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>bind_var x b</code> binds the variable <code>x</code> in <code>b</code>, producing a boxed binder.</p></dd></dl><dl><dt class="spec value" id="val-bind_mvar"><a href="#val-bind_mvar" class="anchor"></a><code><span class="keyword">val</span> bind_mvar : <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>bind_mvar xs b</code> binds the variables of <code>xs</code> in <code>b</code> to get a boxed binder. It is the equivalent of <code>bind_var</code> for multiple variables.</p></dd></dl><dl><dt class="spec value" id="val-box_binder"><a href="#val-box_binder" class="anchor"></a><code><span class="keyword">val</span> box_binder : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_binder f b</code> boxes the binder <code>b</code> using the boxing function <code>f</code>. Note that when <code>b</code> is closed, it is immediately boxed using the <code>box</code> function. In that case, the function <code>f</code> is not used at all.</p></dd></dl><dl><dt class="spec value" id="val-box_mbinder"><a href="#val-box_mbinder" class="anchor"></a><code><span class="keyword">val</span> box_mbinder : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_mbinder f b</code> boxes the multiple binder <code>b</code> using the boxings function <code>f</code>. Note that if <code>b</code> is closed then it is immediately boxed (with <code>box</code>), without relying on <code>f</code> at all.</p></dd></dl><aside><p>As mentioned earlier, terms with bound variables can only be built in the <code>'a box</code> type. To ease the construction of terms, it is a good practice to implement “smart constructors” at the <code>'a box</code> level. Coming back to our λ-calculus example, we can give the following smart constructors.</p><pre><code class="ml">let var : term var -&gt; term box =
  fun x -&gt; box_var x

let abs : term var -&gt; term box -&gt; term box =
  fun x t -&gt; box_apply (fun b -&gt; Abs(b)) (bind_var x t)

let app : term box -&gt; term box -&gt; term box =
  fun t u -&gt; box_apply2 (fun t u -&gt; App(t,u)) t u </code></pre></aside><dl><dt class="spec value" id="val-unbox"><a href="#val-unbox" class="anchor"></a><code><span class="keyword">val</span> unbox : <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>unbox e</code> can be called when the construction of a term is finished (e.g., when the desired variables have all been bound).</p></dd></dl><aside><p>We can then easily define terms of the lambda-calculus as follows.</p><pre><code class="ml">let id    : term = (* λx.x *)
  let x = new_var &quot;x&quot; mkfree in
  unbox (abs x (var x))

let fst   : term = (* λx.λy.x *)
  let x = new_var &quot;x&quot; mkfree in
  let y = new_var &quot;y&quot; mkfree in
  unbox (abs x (abs y (var x)))

let omega : term = (* (λx.(x) x) λx.(x) x *)
  let x = new_var &quot;x&quot; mkfree in
  let delta = abs x (app (var x) (var x)) in
  unbox (app delta delta) </code></pre></aside></section><section><header><h3 id="more-binding-box-manipulation-functions"><a href="#more-binding-box-manipulation-functions" class="anchor"></a>More binding box manipulation functions</h3></header><aside><p>In general, it is not difficult to use the <code>box</code> and <code>apply_box</code> functions to manipulate any kind of data in the <code>'a box</code> type. However, working with these functions alone can be tedious. The following functions can be used to manipulate standard data types in an optimised way.</p></aside><dl><dt class="spec value" id="val-box_opt"><a href="#val-box_opt" class="anchor"></a><code><span class="keyword">val</span> box_opt : <span><span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> option</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_opt bo</code> shifts the <code>option</code> type of <code>bo</code> into the <code>box</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_list"><a href="#val-box_list" class="anchor"></a><code><span class="keyword">val</span> box_list : <span><span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_list bs</code> shifts the <code>list</code> type of <code>bs</code> into the <code>box</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_rev_list"><a href="#val-box_rev_list" class="anchor"></a><code><span class="keyword">val</span> box_rev_list : <span><span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_rev_list bs</code> is similar to <code>box_list bs</code>, but the produced boxed list is reversed (it is hence more efficient).</p></dd></dl><dl><dt class="spec value" id="val-box_array"><a href="#val-box_array" class="anchor"></a><code><span class="keyword">val</span> box_array : <span><span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> array</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> array</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_array bs</code> shifts the <code>array</code> type of <code>bs</code> into the <code>box</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_apply3"><a href="#val-box_apply3" class="anchor"></a><code><span class="keyword">val</span> box_apply3 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_apply3</code> is similar to <code>box_apply2</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_apply4"><a href="#val-box_apply4" class="anchor"></a><code><span class="keyword">val</span> box_apply4 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'e</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_apply4</code> is similar to <code>box_apply2</code> and <code>box_apply3</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_pair"><a href="#val-box_pair" class="anchor"></a><code><span class="keyword">val</span> box_pair : <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_pair ba bb</code> is the same as <code>box_apply2 (fun a b -&gt; (a,b)) ba bb</code>.</p></dd></dl><dl><dt class="spec value" id="val-box_triple"><a href="#val-box_triple" class="anchor"></a><code><span class="keyword">val</span> box_triple : <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>box_triple</code> is similar to <code>box_pair</code>, but for triples.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Map"><a href="#module-type-Map" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Map/index.html">Map</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Type of a module equipped with a <code>map</code> function.</p></dd></dl><dl><dt class="spec module" id="module-Lift"><a href="#module-Lift" class="anchor"></a><code><span class="keyword">module</span> <a href="Lift/index.html">Lift</a> : <span class="keyword">functor</span> (<a href="Lift/argument-1-M/index.html">M</a> : <a href="index.html#module-type-Map">Map</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Functorial interface used to build lifting functions for any type equipped with a <code>map</code> function. In other words, this function can be used to allow the permutation of the <code>'a box</code> type with another type constructor.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Map2"><a href="#module-type-Map2" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Map2/index.html">Map2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Type of a module equipped with a &quot;binary&quot; <code>map</code> function.</p></dd></dl><dl><dt class="spec module" id="module-Lift2"><a href="#module-Lift2" class="anchor"></a><code><span class="keyword">module</span> <a href="Lift2/index.html">Lift2</a> : <span class="keyword">functor</span> (<a href="Lift2/argument-1-M/index.html">M</a> : <a href="index.html#module-type-Map2">Map2</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Similar to the <code>Lift</code> functor, but handles &quot;binary&quot; <code>map</code> functions.</p></dd></dl></section><section><header><h3 id="attributes-of-variables-and-utilities"><a href="#attributes-of-variables-and-utilities" class="anchor"></a>Attributes of variables and utilities</h3></header><dl><dt class="spec value" id="val-hash_var"><a href="#val-hash_var" class="anchor"></a><code><span class="keyword">val</span> hash_var : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash_var x</code> computes a hash for variable <code>x</code>. Note that this function can be used with the <code>Hashtbl</code> module.</p></dd></dl><dl><dt class="spec value" id="val-compare_vars"><a href="#val-compare_vars" class="anchor"></a><code><span class="keyword">val</span> compare_vars : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_vars x y</code> safely compares <code>x</code> and <code>y</code>. Note that it is unsafe to compare variables using <code>Pervasive.compare</code>.</p></dd></dl><dl><dt class="spec value" id="val-eq_vars"><a href="#val-eq_vars" class="anchor"></a><code><span class="keyword">val</span> eq_vars : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eq_vars x y</code> safely computes the equality of <code>x</code> and <code>y</code>. Note that it is unsafe to compare variables with the polymorphic equality function.</p></dd></dl></section><section><header><h3 id="attributes-of-binders-and-utilities"><a href="#attributes-of-binders-and-utilities" class="anchor"></a>Attributes of binders and utilities</h3></header><dl><dt class="spec value" id="val-binder_name"><a href="#val-binder_name" class="anchor"></a><code><span class="keyword">val</span> binder_name : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>binder_name</code> returns the name of the variable bound by the <code>binder</code>.</p></dd></dl><dl><dt class="spec value" id="val-binder_occur"><a href="#val-binder_occur" class="anchor"></a><code><span class="keyword">val</span> binder_occur : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>binder_occur b</code> tests whether the bound variable occurs in <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-binder_constant"><a href="#val-binder_constant" class="anchor"></a><code><span class="keyword">val</span> binder_constant : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>binder_constant b</code> tests whether the <code>binder</code> <code>b</code> is constant (i.e., its bound variable does not occur).</p></dd></dl><dl><dt class="spec value" id="val-binder_closed"><a href="#val-binder_closed" class="anchor"></a><code><span class="keyword">val</span> binder_closed : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>binder_closed b</code> test whether the <code>binder</code> <code>b</code> is closed (i.e., does not contain any free variable).</p></dd></dl><dl><dt class="spec value" id="val-binder_rank"><a href="#val-binder_rank" class="anchor"></a><code><span class="keyword">val</span> binder_rank : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>binder_rank b</code> gives the number of free variables contained in <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_arity"><a href="#val-mbinder_arity" class="anchor"></a><code><span class="keyword">val</span> mbinder_arity : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>mbinder_arity b</code> gives the arity of the <code>mbinder</code>.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_names"><a href="#val-mbinder_names" class="anchor"></a><code><span class="keyword">val</span> mbinder_names : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span>string array</span></code></dt><dd><p><code>mbinder_names b</code> return the array of the names of the variables bound by the <code>mbinder</code> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_occurs"><a href="#val-mbinder_occurs" class="anchor"></a><code><span class="keyword">val</span> mbinder_occurs : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span>bool array</span></code></dt><dd><p><code>mbinder_occurs b</code> returns an array of <code>bool</code> indicating if the variables that are bound occur (i.e., are used).</p></dd></dl><dl><dt class="spec value" id="val-mbinder_constant"><a href="#val-mbinder_constant" class="anchor"></a><code><span class="keyword">val</span> mbinder_constant : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mbinder_constant b</code> indicates whether the <code>mbinder</code> <code>b</code> is constant. This means that none of its variables are used.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_closed"><a href="#val-mbinder_closed" class="anchor"></a><code><span class="keyword">val</span> mbinder_closed : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mbinder_closed b</code> indicates whether <code>b</code> is closed.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_rank"><a href="#val-mbinder_rank" class="anchor"></a><code><span class="keyword">val</span> mbinder_rank : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h3 id="attributes-of-binding-boxes-and-utilities"><a href="#attributes-of-binding-boxes-and-utilities" class="anchor"></a>Attributes of binding boxes and utilities</h3></header><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_closed b</code> checks whether the <code>box</code> <code>b</code> is closed.</p></dd></dl><dl><dt class="spec value" id="val-occur"><a href="#val-occur" class="anchor"></a><code><span class="keyword">val</span> occur : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>occur x b</code> tells whether variable <code>x</code> occurs in the <code>box</code> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind_apply"><a href="#val-bind_apply" class="anchor"></a><code><span class="keyword">val</span> bind_apply : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>bind_apply bb barg</code> substitute the boxed binder <code>bb</code> with the boxed value <code>barb</code> in the <code>box</code> type. This function is useful when working with higher order variables, which may be represented as binders themselves.</p></dd></dl><dl><dt class="spec value" id="val-mbind_apply"><a href="#val-mbind_apply" class="anchor"></a><code><span class="keyword">val</span> mbind_apply : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> array</span> <a href="index.html#type-box">box</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>mbind_apply bb bargs</code> substitute the boxed binder <code>bb</code> with a boxed array of values <code>barbs</code> in the <code>box</code> type. This function is useful when working with higher order variables.</p></dd></dl></section><section><header><h3 id="working-in-a-context"><a href="#working-in-a-context" class="anchor"></a>Working in a context</h3></header><aside><p>It is sometimes convenient to work in a context for variables, for example when one wishes to reserve variable names. The <code>Bindlib</code> library provides a type of contexts, together with functions for creating variables and for binding variables in a context.</p></aside><dl><dt class="spec type" id="type-ctxt"><a href="#type-ctxt" class="anchor"></a><code><span class="keyword">type</span> ctxt</code></dt><dd><p>Type of a context.</p></dd></dl><dl><dt class="spec value" id="val-empty_ctxt"><a href="#val-empty_ctxt" class="anchor"></a><code><span class="keyword">val</span> empty_ctxt : <a href="index.html#type-ctxt">ctxt</a></code></dt><dd><p><code>empty_ctxt</code> denotes the empty context.</p></dd></dl><dl><dt class="spec value" id="val-new_var_in"><a href="#val-new_var_in" class="anchor"></a><code><span class="keyword">val</span> new_var_in : <a href="index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> * <a href="index.html#type-ctxt">ctxt</a></code></dt><dd><p><code>new_var_in ctxt mkfree name</code> is similar to <code>new_var mkfree name</code>, but the variable names is chosen not to collide with the context <code>ctxt</code>. Note that the context that is returned contains the new variable name.</p></dd></dl><dl><dt class="spec value" id="val-new_mvar_in"><a href="#val-new_mvar_in" class="anchor"></a><code><span class="keyword">val</span> new_mvar_in : <a href="index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>string array</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> * <a href="index.html#type-ctxt">ctxt</a></code></dt><dd><p><code>new_mvar_in ctxt mkfree names</code> is similar to <code>new_mvar mkfree names</code>, but it handles the context (see <code>new_var_in</code>).</p></dd></dl><dl><dt class="spec value" id="val-unbind_in"><a href="#val-unbind_in" class="anchor"></a><code><span class="keyword">val</span> unbind_in : <a href="index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> * <span class="type-var">'b</span> * <a href="index.html#type-ctxt">ctxt</a></code></dt><dd><p><code>unbind_in ctxt b</code> is similar to <code>unbind b</code>, but it handles the context as explained in the documentation of <code>new_mvar_in</code>.</p></dd></dl><dl><dt class="spec value" id="val-unmbind_in"><a href="#val-unmbind_in" class="anchor"></a><code><span class="keyword">val</span> unmbind_in : <a href="index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> * <span class="type-var">'b</span> * <a href="index.html#type-ctxt">ctxt</a></code></dt><dd><p><code>unmbind_in ctxt b</code> is like <code>unmbind b</code>, but it handles the context as is explained in the documentation of <code>new_mvar_in</code>.</p></dd></dl></section><section><header><h3 id="unsafe,-advanced-features"><a href="#unsafe,-advanced-features" class="anchor"></a>Unsafe, advanced features</h3></header><dl><dt class="spec value" id="val-uid_of"><a href="#val-uid_of" class="anchor"></a><code><span class="keyword">val</span> uid_of : <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>uid_of x</code> returns a unique identifier of the given variable.</p></dd></dl><dl><dt class="spec value" id="val-uids_of"><a href="#val-uids_of" class="anchor"></a><code><span class="keyword">val</span> uids_of : <span><span class="type-var">'a</span> <a href="index.html#type-mvar">mvar</a></span> <span>&#45;&gt;</span> <span>int array</span></code></dt><dd><p><code>uids_of xs</code> returns the unique identifiers of the variables of <code>xs</code>.</p></dd></dl><dl><dt class="spec value" id="val-copy_var"><a href="#val-copy_var" class="anchor"></a><code><span class="keyword">val</span> copy_var : <span><span class="type-var">'b</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span></code></dt><dd><p><code>copy_var x mkfree name</code> makes a copy of variable <code>x</code>, with a potentially different name and <code>mkfree</code> function. However, the copy is treated exactly as the original in terms of binding and substitution. The main application of this function is for translating abstract syntax trees while preserving binders. In particular, variables at two different types should never live together (this may produce segmentation faults).</p></dd></dl><dl><dt class="spec value" id="val-reset_counter"><a href="#val-reset_counter" class="anchor"></a><code><span class="keyword">val</span> reset_counter : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset_counter ()</code> resets the unique identifier counter on which <code>Bindlib</code> relies. This function should only be called when previously generated data (e.g., variables) cannot be accessed anymore.</p></dd></dl><dl><dt class="spec value" id="val-dummy_box"><a href="#val-dummy_box" class="anchor"></a><code><span class="keyword">val</span> dummy_box : <span><span class="type-var">'a</span> <a href="index.html#type-box">box</a></span></code></dt><dd><p><code>dummy_box</code> can be used for initialising structures like arrays. Note that if <code>unbox</code> is called on a data structure containing <code>dummy_box</code>, then the exception <code>Failure &quot;Invalid use of dummy_box&quot;</code> is raised.</p></dd></dl><dl><dt class="spec value" id="val-binder_compose"><a href="#val-binder_compose" class="anchor"></a><code><span class="keyword">val</span> binder_compose : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-binder">binder</a></span></code></dt><dd><p><code>binder_compose b f</code> postcomposes the binder <code>b</code> with the function <code>f</code>. In the process, the binding structure is not changed. Note that this function is not always safe. Use it with care.</p></dd></dl><dl><dt class="spec value" id="val-mbinder_compose"><a href="#val-mbinder_compose" class="anchor"></a><code><span class="keyword">val</span> mbinder_compose : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span></code></dt><dd><p><code>mbinder_compose b f</code> postcomposes the multiple binder <code>b</code> with <code>f</code>. This function is similar to <code>binder_compose</code>, and it is not always safe.</p></dd></dl><dl><dt class="spec value" id="val-raw_binder"><a href="#val-raw_binder" class="anchor"></a><code><span class="keyword">val</span> raw_binder : string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-binder">binder</a></span></code></dt><dd><p><code>raw_binder name bind rank mkfree value</code> builds a binder using the <code>value</code> function as its definition. The parameter <code>name</code> correspond to a preferred name of the bound variable, the boolean <code>bind</code> indicates whether the bound variable occurs, and <code>rank</code> gives the number of distinct free variables in the produced binder. The <code>mkfree</code> function injecting variables in the type <code>'a</code> of the domain of the binder must also be given. This function must be considered unsafe because it is the responsibility of the user to give the accurate value for <code>bind</code> and <code>rank</code>.</p></dd></dl><dl><dt class="spec value" id="val-raw_mbinder"><a href="#val-raw_mbinder" class="anchor"></a><code><span class="keyword">val</span> raw_mbinder : <span>string array</span> <span>&#45;&gt;</span> <span>bool array</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-var">var</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-mbinder">mbinder</a></span></code></dt><dd><p><code>raw_mbinder names binds rank mk_free value</code> is similar to <code>raw_binder</code>, but it is applied to a multiple binder. As for <code>raw_binder</code>, this function has to be considered unsafe because the user must enforce invariants.</p></dd></dl></section></div></body></html>
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{ocamldoc}
\usepackage{textcomp}

\title{
  Bindlib, version 4.0 \\
  A package for abstract syntax with binder
}
\author{
  Christophe Raffalli \& Rodolphe Lepigre \\
  UniversitÃ© Savoie Mont Blanc
}

\begin{document}
\maketitle

\vspace{1cm}
\begin{abstract}
  Bindlib is an \verb#OCaml# library providing a set of tools for managing
  data structures with (bound and free) variables. It is very well suited for
  defining abstract syntax trees.
  %
  Bindlib includes support for fast substitutions and for the management of
  variables names. In particular, bound variables are renamed in a minimal
  way to avoid capture.
\end{abstract}
\vspace{1cm}

\tableofcontents

\section{Introduction}

Data structures with bound and free variables are very common in computer
science. For instance, they are required to encode mathematical formulas or
computer programs into so-called abstract syntax trees. The manipulation of
bound and free variables is hence essential when it comes to writing
compilers or proof assistants. However, implementing the necessary primitives
(mainly capture-avoiding substitution and renaming) is cumbersome. Moreover,
the simplest implementations often result in poor performance, especially
when a lot of substitutions are required. Bindlib aims at providing a library
that enables both simplicity and efficiency. It provides high-level tools for
deal with binders, substitutions and free variables.

This documentation is in two parts : an informal presentation
introducing each concept step by step illustrated with examples. Then,
a more formal presentation in the appendix which includes the syntax
and an equational semantics of the library.

For our examples, we assume basic knowledge of the $\lambda$-calculus
which is the simplest data structure with bound variables (Wikipedia
has a good introduction on this topic). For the second example, we
will give the required mathematical definitions.

\section{Using and installing}

Bindlib works with \verb#OCaml# version 3.12.1 or later, but it has not been
tested with earlier versions. It can be compiled and installed using the
command
\begin{center}
  \verb#make && make install#
\end{center}
in the source directory. Alternatively, Bindlib can be installed using the
\verb#opam# package manager using the following command.
\begin{center}
  \verb#opam install bindlib#
\end{center}

Several examples of applications (including an implementation of the
$\lambda$-calculus) are provided in Bindlib's source directory (or in
\verb#opam#'s doc directory if you installed via \verb#opam#).

\section{Basic types}

The main type constructor provided by Bindlib is \verb#('a,'b) binder#. It
corresponds to a value of type \verb#'b# with one bound variable of type
\verb#'a#. Intuitively, it is very similar to the type \verb#'a -> 'b# used
when using higher-order abstract syntax. For free variables, bindlib provides
a type \verb#'a variable# for free variable of type \verb#'a#. Using these
types, we can define the type of $\lambda$-terms as follows.
\begin{quote}
\begin{verbatim}
type term =
  | App of term * term         (* application                 *)
  | Lam of (term, term) binder (* abstraction (i.e. function) *)
  | Var of term variable       (* free variable               *)
\end{verbatim}
\end{quote}

\section{How to use a data structure with variables ?}

Consider the following function to convert lambda-terms to string:

\begin{quote}
\begin{verbatim}
let fVar x = Var(x)

let rec term_to_string = function
  | Var x    -> name_of x
  | Lam b    -> let (x,t) = unbind b in
                "\\" ^ (name_of x) ^ (term_to_string t)
  | App(t,u) -> (term_to_string t) ^ "(" ^ (term_to_string u) ^ ")"
\end{verbatim}
\end{quote}

The function \verb!fVar! is just a synonymous of the type constructor
\verb!Var! that can be easily passed in argument to functions.

Printing application is immediate, just recursive calls. All cases not
dealing with bindlib's type constructor should be straightforward. For
variables, bindlib manages function name and renaming and provide a
function \verb!name_of : 'a variable -> string! to get the variable name.

For binder, one may use
\begin{quote}
\begin{verbatim}
unbind : ('a, 'b) binder -> ('a variable -> 'a) -> 'a variable *'b
\end{verbatim}
\end{quote}
A natural question arises: what is the
role of the first argument of \verb!unbind!. It is mandatory when
constructing a value of type \verb!'a variable! to provide a function
of type \verb!'a variable -> 'a!, which is used when we need to
consider the variable as an object of type \verb!'a!.

In the above example, \verb!fVar! is not used and it is possible to
replace it by \verb!(fun _ -> assert false)!.

The function \verb!let (x,t) = unbind fVar b in! could be replaced by the following lines:
\begin{quote}
\begin{verbatim}
let name = binder_name f in
let x = new_var name fVar x in
let t = subst f (free_of x) in
\end{verbatim}
\end{quote}

These lines use the following functions:

\begin{itemize}
\item \verb#binder_name : ('a, 'b) binder -> string# to get the name
  of the bound variable that is kept and managed by bindlib.

\item \verb#new_var# is a function to create a new variable.
The name you give is only an indication, it might be changed by
bindlib if necessary, but will be always kept as prefix.

\item \verb#free_of x# is in fact equivalent to \verb#fVar x#.

\item \verb#subst : ('a, 'b) binder -> 'a -> 'b# is finally use to
  substitute a value in place of the bound variable in \verb#f#.
\end{itemize}


\section{How to construct a data structure with variables ?}

To construct data structure with bound variables, we provide a new type
\begin{center}
\verb!'a bindbox!
\end{center}

which is the type of a data structure of type \verb#'a# under
construction.
In fact this type contructor defines a monad. If you do not know what
a monad is just consider this is the notion of morphism associated to
typed programming language. If you do not know what a morphism is,
then just ignore this paragraph !

Using a type \verb!'a bindbox! when constructing a data structure with
bind variable is the main idea behind bindlib. As an approximation,
you can view a value of type \verb!'a bindbox! as a pair with a set
of bound variables, and a function that buid a value of type \verb!'a!
from the value of all these variabes.

Working with \verb!'a bindbox! requires to lift the constructor to
this type. Indeed, we need a some kind of way to transform the
\verb!App! constructor into a term of type
\verb!'a bindbox -> 'a bindbox -> 'a bindbox!. The bindlib library
provide the necessary function to do that in a few lines:

\begin{quote}
\begin{verbatim}
let app : term bindbox -> term bindbox -> term bindbox =
  fun x y -> box_apply2 (fun x y -> App(x,y)) x y
let lam : string -> (term bindbox -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x))
    (let v = new_var fVar name in bind_var v (f (free_of v)))
\end{verbatim}
\end{quote}

Those \emph{smart constructors} are build using the following functions:
\begin{quote}
\begin{verbatim}
box : 'a -> 'a bindbox
apply_box : ('a -> 'b) bindbox -> 'a bindbox -> 'b bindbox
bind_var : 'a variable  -> 'b bindbox -> ('a, 'b) binder bindbox
box_apply : ('a -> 'b) -> 'a bindbox -> 'b bindbox#
box_apply2 : ('a -> 'b -> 'c) -> 'a bindbox -> 'b bindbox -> 'c
\end{verbatim}
\end{quote}

Remark: it you are used to monad, \verb#box# and \verb#apply_box# are
the \verb#return# and \verb#bind# operation of the monad. We did not
use the name \verb#bind# ... Because this name is not appropriate
hare. This means that \verb#box_apply# and \verb#box_apply2# can
easily be defined from \verb#box# and \verb#apply_box#.

The key function to bind variables is \verb#bind_var#. Two short cut
are provided:
\begin{quote}
\begin{verbatim}
let bind fv name f =
  let v = new_var fVar name in bind_var v (f (free_of v))
let vbind fv name f =
  let v = new_var fVar name in bind_var v (f v)
\end{verbatim}
\end{quote}

Using these short cut, we could give a shorter definition and an
alternative version of \verb#lam#:

\begin{quote}
\begin{verbatim}
let lam : string -> (term bindbox -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x)) (bind fVar name f)
let vlam : string -> (term variable -> term bindbox) -> term bindbox =
  fun name f -> box_apply (fun x -> Lam(x)) (vbind fVar name f)
\end{verbatim}
\end{quote}

Depending what we do when we construct a term, we might prefer
the bound variable to be directly of type \verb#term bindbox# as in
\verb#lam# or of type \verb#term variable# as in the latest definition.

Using these \emph{smart constructors}, we can start to define value of
type term. We also need the function \verb#unbox : 'a bindbox -> 'a#
to finalise the construction.
\begin{quote}
\begin{verbatim}
let idt = unbox (lam "x" (fun x -> x))
let delta = unbox (lam "x" (fun x -> app x x))
let omega = App(delta,delta)
\end{verbatim}
\end{quote}

Remark: in the last definition, because we are not binding any new
variables, we do not need to work inside the type \verb#'a bindbox#.

Here is another example, which performs the following transformation on
$\lambda$-term (it marks all the application with a variable and the
bind this variable):
$$
\begin{array}{rcl}
\hbox{mark}(t) &=& \lambda x.\phi_x(t) \cr
\phi_x(y) &=& y \cr
\phi_x(u\,v) &=& x\,\phi_x(u)\,\phi_x(v) \cr
\phi_x(\lambda y.u) &=& \lambda y.(\phi_x u)
\end{array}
$$

Here is the corresponding code, which illustrates the different use
of \verb#lam# and \verb#vlam#:

\begin{verbatim}
let mark t =
  let rec phi x = function
  | Var(y) -> box_of_var y
  | App(u,v) -> app (app x (phi x u)) (phi x v)
  | Lam(f) -> vlam (binder_name f) (fun y -> phi x (subst f (Var y)))
  in unbox (lam "x" (fun x -> phi x t))
\end{verbatim}

This code is very similar to the mathematical definition.
The use of \verb#binder_name f# allows to use the original name
(eventually with a changed suffix).

Here is another example: the computation of the normal form of a term:

\begin{verbatim}
(* weak head normal form *)
let rec whnf = function
  App(t1,t2) as t0 -> (
    match (whnf t1) with
    | Lam f -> whnf (subst f t2)
    | t1' ->
       (* a small optimization here when the term is in whnf *)
       if t1' == t1 then t0 else App(t1', t2))
| t -> t

(* call by name normalisation, all step at once *)
let norm t = let rec fn t =
  match whnf t with
  | Lam f ->
      let (x,t) = unbind fVar f in
      vlam (binder_name f) (fun x -> fn (subst f (Var x)))
  | t ->
      let rec unwind = function
        | Var(x) -> box_of_var x
        | App(t1,t2) -> app (unwind t1) (fn t2)
        | t -> assert false
      in unwind t
in unbox (fn t)
\end{verbatim}

This function is very similar to the previous one, with one function
to compute the ``weak head normal form'', which is used in the second
function to compute the full normal form.

\section{Naming of variables}

The bindlib library uses \verb#string# for variable names. Names are
considered
as the concatenation of a prefix and a possibly empty suffix. The
suffix is the longest terminal substring of the name composed only of
digits.

Example: in \verb#"toto0"# the suffix is \verb#"0"#.

To choose the initial name of a variable, you use the \verb#"as"#
keyword in

\begin{verbatim}
letvar f x as name in t
\end{verbatim}

This means that \verb#name_of x# will return \verb#name#. However,
when binding \verb#x# using \verb#bindvar x in u#, the suffix of
the name may be changed to avoid name conflict. In
\verb#letvar f x in t#, the default name for \verb#x# will be
\verb#"x"# (that is the string build from the name of the identifier).

To access the name of variables, bindlib provides the following
functions:

\begin{itemize}
\item \verb#name_of : 'a variable -> string# to access the name of a free
  variable.

\item \verb#binder_name : ('a, 'b) variable -> string# to access the
  name of a bound variable.

\item \verb#match t with bind f x in u -> ...#: if
 \verb#t : ('a, 'b) binder#, then we have \verb#x# of type \verb#'a variable# and
 \verb#name_of x# will return the same value as \verb#binder_name t#.
\end{itemize}

Using bindlib you are sure that bound variables are renamed to avoid
variable conflict. But this is not enough:
\begin{enumerate}
\item Distinct free variables may have the same name. Renaming of free
  variables can not be done automatically because there is no way to
  know the variables that are used in the same ``context''.
\item The \verb#subst# function does not perform renaming. Therefore,
  it is only just after the call to \verb#unbox# that the bound
  variables are named correctly. If you use the result of \verb#unbox#
  and perform substitution then, the naming may become incorrect.

  This can not be avoided if one want a reasonable complexity for
  substitution.

\item By default, bindlib perform minimal renaming. This means it
  accepts name collision in \verb#fun x -> fun x -> x# that you might prefer printed as
\verb#fun x -> fun x0 -> x0#.
\end{enumerate}

To solve these problems, bindlib provides an abstract notion of context
 which are ``sets'' of free variables which should have
 distinct names.
\begin{itemize}
\item\verb#type context# is  an abstract type.
\item\verb#empty_context : context# is the initial empty context.
\item\verb#letvar f x as name for ctxt in ...# The argument of \verb#for# must be an Ocaml
identifier of type \verb#context#. The name given with \verb#as name#
may be changed (only the suffix is changed) into a name not already in
\verb#ctxt#. Then, the identifier  \verb#ctxt# is rebound, under the
scope of \verb#letvar#, to an extended context containing the new variable name.

This construct can also
be used with the \verb#bind f x as name for ctxt in ...# camlp4 extension.
\end{itemize}

This fixes point (1). For the two other points, there are two solutions,
depending if you prefer minimal renaming or the so called Barendregt
convention (no bound variable should have the same name than a free
variable, even is the later does not occur in the scope of the
former).

If you want to follow Barendregt convention, this is easy, your
printing functions should use a \verb#context# as in:

\begin{verbatim}
let rec print_term ctxt = function
  App(t1,t2) ->
    print_string "(";
    print_term ctxt t1;
    print_string " ";
    print_term ctxt t2;
    print_string ")"
| Abs f ->
    match f with bind fVar x for ctxt in t ->
      print_string "fun ";
      print_string (name_of x);
      print_string " ";
      print_term ctxt t
| FVar(v) ->
    print_string (name_of v)
\end{verbatim}

If you prefer minimal renaming (which is required when you really want
to refer to names of bound variables), you have nothing to do if you are
certain that no substitution have been performed. Otherwise, you need
what I call a ``lifting'' function to copy the data structure before
printing as in the following example:

\begin{verbatim}
let rec lift_term = function
    FVar(y) -> bindbox_of y
  | App(u,v) -> App(^lift_term u, lift_term v^)
  | Abs(f) ->
      match f with bind fVar x in u ->
        Abs(^ bindvar x in lift_term u ^)

let print_term t =
  let rec fn = function
      App(t1,t2) ->
        print_string "(";
        fn t1;
        print_string " ";
        fn t2;
        print_string ")"
    | Abs f ->
        match f with bind fVar x in t ->
          print_string "fun ";
          print_string (name_of x);
          print_string " ";
          fn t
    | FVar(v) ->
        print_string (name_of v)
  in
  fn (unbox (lift_term t))
\end{verbatim}

\section{A more complete example and advanced features}

This section covers advanced feature of the library. The reader is
advised to read, practise and understand the previous section before
reading this.

We will consider second order predicate logic.
We chose this example, because the definition of second-order
substitution is non trivial ... and this is a very good example for
the power of \verb#bindlib#.

Here is the mathematical definition of terms and formulas, and the
corresponding definition using \verb#bindlib#:

\newtheorem{definition}{definition}\
\begin{definition}[Syntax of second order logic]\rm
We assume a signature
$$\Sigma = \{(f,1), (g,2), (a,0), \dots\}$$ with various
constants and function symbols of
various arity. An infinite set of first-order variables (written
$x,y,z\dots$) and for each natural number $n$ an infinite set of
second-order variables of arity $n$ (written $X,Y,Z,\dots$).

Terms are defined by
\begin{itemize}
\item $x$ is a term if it is a first order variable
\item $f(t_1,\dots,t_n)$ is a term if $f$ is a function symbol of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\end{itemize}

Formulas are defined by
\begin{itemize}
\item $X(t_1,\dots,t_n)$ is a formula if $X$ is a second order variable of
arity $n$ and if $t_1,\dots,t_n$ are terms.
\item $A \to B$ is a formula if $A$ and $B$ are formulas.
\item $\forall x\,A$ is a formula with $x$ bound if $A$ is a formula
and $x$ is a first-order variable.
\item $\forall X\,A$ is a formula with $X$ bound if $A$ is a formula
and $X$ is a second-order variable.
\end{itemize}
\end{definition}

\begin{verbatim}
(* a structure to store the information about a function symbol *)
type symbol = {name : string; arity : int }

(* the type of first order term *)
type term =
    Fun of symbol * term array
  | TermVar of term variable

(* the type of second order formula *)
type form =
  Imply of form * form
| Forall1 of (term, form) binder         (* fitst order quantifier *)
| Forall2 of int * (pred, form) binder   (* second order quantifier *)
                                         (* the int in the arity *)
| FormVar of pred variable * term array  (* a predicate variables and *)
                                         (* its arguments *)

and pred = (term, form) mbinder          (* a predicate is a binder ! *)

let lam1 x = TermVar(x)

let lam2 n x =
  unbox (bind lam1 args(n) in FormVar(^ (^x^), lift_array args^))
\end{verbatim}

Let us review these definitions:
\begin{itemize}
\item \verb#pred = (term, form) mbinder#: this is the type of an object
of type \verb#form# with an array of bound variables. We use this to
represent predicates, that is formula with $n$ parameters.

\item \verb#Forall2 of int * (pred, form) binder#: for second order
quantification, we bind a variable of arity $n$. The arity is the
first argument of the constructor. For the second argument,
\verb#(pred, form) binder#, we mean that we bind a ``predicate''
variable. This variable is
itself a \verb#mbinder#, this is why it is a ``second-order'' variable.

\item \verb#FormVar of pred variable * term array#: as usual
for any free variable, we have to store
the variable itself of type \verb#pred variable#.
But here, we should also store the terms which
are the arguments of the second-order predicate variable.

\item \verb#let lam1 x = TermVar(x)#: we introduce the
function to construct first-order binder. Every time we will want to
construct a first-order quantification, we will write

\verb#Forall1(^ bind lam1 x in ... ^)#

\item \verb#bind lam1 args(n) in ...# : this binds an array of
  \verb#term variable# of arity \verb#n#. The typing rule of this camlp4
extension is:
$$
\frac{
\begin{array}{l}\Gamma, \hbox{\tt x :$\!$ 'a array bindbox} \vdash \hbox{\tt e
:$\!$ 'b bindbox}
\cr \Gamma \vdash \hbox{\tt f :$\!$ 'a variable
-> 'a}
\cr \Gamma \vdash \hbox{\tt n : int}
\end{array}}
{\Gamma \vdash \hbox{\tt bind f x(n) in e :$\!$ ('a, 'b) mbinder bindbox}}
$$

\item \verb#lift_array# : this is a function of type
  \verb#'a bindbox array -> 'a array binxbox#, which is often used when
  binding array of variables.

\item \verb#let lam2 n x =#\\
\verb#  unbox (bind lam1 args(n) in FormVar(^ (^x^), lift_array args^))#:
we introduce the
function to construct second-order binder. It is a bit complex, but
typing gives very little choice: we have \verb#arity : int#,
and \verb#x : pred variable#. And we need an
object of type \verb#pred#. We have:

\begin{itemize}
\item \verb#x : pred variable# and therefore,
\verb#(^x^) : pred variable bindbox#
\item \verb#args : term bindbox array# gives
\verb#lift_array args : term array bindbox#
\item all this gives
\verb#FormVar(^ ... ^) : form bindbox#, using the rule given page
\pageref{liftconstr} for lifted constructor.
\item
\verb#bind lam1 args(arity) in FormVar(^ ... ^) : pred bindbox#.
\item Finally, \verb#unbox (bind lam1 args(arity) in FormVar(^ ... ^)) : pred#
\end{itemize}

Like for first-order variables, every time we will want to
construct a second-order quantification of arity \verb#n#, we will write
\verb#Forall2(^ unit n, bind lam2 x(n) in ... ^)#.
\end{itemize}

Now, we write the printing function for terms and formulas:

\begin{verbatim}
let rec print_term = function
    Fun(sy, ta) ->
      print_string sy.name;
      print_string "(";
      for i = 0 to sy.arity - 1 do
        print_term ta.(i);
        print_string (if i < sy.arity - 1 then "," else ")")
      done
  | TermVar(var) ->
      print_string (name_of var)

let rec print_form lvl = function
    Imply(f1, f2) ->
      if lvl > 0 then print_string "(";
      print_form 1 f1; print_string " => "; print_form lvl f2;
      if lvl > 0 then print_string ")";
  | Forall1 f ->
      match f with bind lam1 t  in g ->
        print_string "Forall1 ";
        print_string (name_of t);
        print_string " ";
        print_form 1 g
  | Forall2 (arity, f) ->
      match f with bind (lam2 arity) x in g ->
      print_string "Forall2 ";
      print_string (name_of x);
      print_string " ";
      print_form 1 g
  | FormVar(var,args) ->
      print_string (name_of var);
      print_string "(";
      let arity = Array.length args in
      for i = 0 to arity - 1 do
        print_term args.(i);
        print_string (if i < arity - 1 then "," else ")")
      done
\end{verbatim}

We also write the equality test which is similar:
\begin{verbatim}
let rec equal_term t t' = match t, t' with
    TermVar(x), TermVar(x') -> x == x'
  | Fun(sy,ta), Fun(sy',ta') when sy = sy' ->
      let r = ref true in
      for i = 0 to sy.arity - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false

let rec equal_form f f' = match f, f' with
    Imply(f,g), Imply(f',g') ->
      equal_form f f' && equal_form g g'
  | Forall1(f), Forall1(f') ->
      match f with bind lam1 t in g ->
      equal_form g (subst f' (free_of t))
  | Forall2(arity,f), Forall2(arity',f') ->
      arity = arity' &&
      match f with bind (lam2 arity) x in g ->
      equal_form g (subst f' (free_of x))
  | FormVar(x,ta), FormVar(x',ta') ->
      x == x' &&
      let r = ref true in
      for i = 0 to Array.length ta - 1 do
        r := !r && equal_term ta.(i) ta'.(i)
      done;
      !r
  | _ -> false
\end{verbatim}

One remark here: we do not use the variables names for comparison
(because it is slower and for another reason that we will see later),
but instead we use physical equality on the free variables we create to substitute to
bound variables.
It is possible to use structural equality because a
variable is a structure whose first field is a unique identifier. But
you should be aware that one of the field of this structure is an ML
closure (the function of type \verb#'a variable -> 'a# given when
creating the variable).

Now, we give the lifting functions (already mentioned about naming): very often, we have
an object \verb#o# of type \verb#t bindbox# that we want to
read/match. Therefore, we will use \verb#unbox#.
But then, we will want to reuse the subterms of \verb#o# with
type  \verb#t bindbox# to continue the construction of an object of
type \verb#t# with some bound variables. For this, we need this kind
of copying functions:

\begin{verbatim}
let rec lift_term = function
    TermVar(x) -> bindbox_of x
  | Fun(sy,ta) -> Fun(^ (^sy^), lift_array (Array.map lift_term ta) ^)

let rec lift_form = function
    Imply(f1,f2) -> Imply(^ lift_form f1, lift_form f2 ^)
  | Forall1 f ->
      match f with bind lam1 t in g ->
       Forall1(^ bindvar t in lift_form g ^)
  | Forall2(arity,f) ->
      match f with bind (lam2 arity) x in g ->
      Forall2(^ (^arity^), bindvar x in lift_form g ^)
  | FormVar(x,args) ->
      mbind_apply (bindbox_of x) (lift_array (Array.map lift_term args))
\end{verbatim}

The functions
\verb#bind_apply : ('a -> 'b) binder bindbox -> 'a bindbox -> 'b bindbox# and
\verb#mbind_apply  ('a -> 'b) mbinder bindbox -> 'a bindbox array -> 'b bindbox#
for multiple binder are
used to apply to its arguments a variable representing a binder.

Now we define proofs (for natural deduction):
\begin{verbatim}
type proof =
    Imply_intro of form * (proof,proof) binder
  | Imply_elim of proof * proof
  | Forall1_intro of (term, proof) binder
  | Forall1_elim of proof * term
  | Forall2_intro of int * (pred, proof) binder
  | Forall2_elim of proof * pred
  | Axiom of form * proof variable

let assume f x = Axiom(f,x)
\end{verbatim}

We remark that all introduction rules are binder and the
implication introduction rule binds a proof inside a proof.
For the function \verb#assume# constructing the variables of type
\verb#proof#, we also store the formula that it ``assumes'' when we do
the introduction of an implication.

Now, we give a simple function to print goals (or sequent), that is a
list of named hypotheses, represented by proof variables, and a
conclusion. We need to copy the hypotheses because they result from a
substitution. This is not the case for the conclusion of the sequent
which is passed to \verb#print_goal# just after the call to \verb#unbox#.
\begin{verbatim}
let print_goal hyps concl =
  List.iter (
  function
      Axiom(f, v) ->
        print_string (name_of v); print_string ":=";
        print_form 0 (unbox (lift_form f)); print_newline ()
    | _ ->
        failwith ("not an axiom")) hyps;
  print_string "  |- "; print_form 0 concl; print_newline ()
\end{verbatim}

Now the main function, that checks if a proof is correct. The first
function builds the formula which is proved by a proof, or raise the
exception \verb#Bad_proof# if the proof is incorrect.

The second function calls the first one and checks if the produced
formula is equal to a given formula.

Moreover, to illustrate the problem of variables names, we print the
goal which is obtained after each rule.

Here is the code that we will explain bellow:
\begin{verbatim}
exception Bad_proof of string

let type_infer p =
  let ctxt = empty_context in
  let rec fn hyps ctxt p =
    let r = match p with
      Imply_intro(f,p) ->
        match p with bind (assume f) ax for ctxt in p' ->
        Imply(^ lift_form f, fn (ax::hyps) ctxt p' ^)
    | Imply_elim(p1, p2) ->
        begin
          let f1' = unbox (fn hyps ctxt p2) in
          match unbox (fn hyps ctxt p1) with
            Imply(f1,f2) when equal_form f1 f1' -> lift_form f2
          | Imply(f1,f2) ->
              print_form 0 f1; print_string "<>"; print_form 0 f1';
              print_newline ();
              raise (Bad_proof("Imply"))
          | _ ->
              raise (Bad_proof("Imply"))
        end
    | Forall1_intro(p) ->
        match p with bind lam1 t for ctxt in p' ->
        Forall1(^ bindvar t in  fn hyps ctxt p'^)
    | Forall1_elim(p,t) ->
        begin
          match unbox (fn hyps ctxt p) with
            Forall1(f) -> lift_form (subst f t)
          | _ -> raise (Bad_proof("Forall1"))
        end
    | Forall2_intro(arity, f) ->
        match f with bind (lam2 arity) x for ctxt in p' ->
        Forall2(^ (^arity^),  bindvar x in fn hyps ctxt p' ^)
    | Forall2_elim(p,pred) ->
        begin
          match unbox (fn hyps ctxt p) with
n            Forall2(arity, f) when arity = mbinder_arity pred ->
              lift_form (subst f pred)
          | _ -> raise (Bad_proof("Forall2"))
        end
    | Axiom(f,_) ->
        lift_form f
    in
    print_goal (List.map free_of hyps) (unbox r); print_newline ();
    r
  in
  unbox (fn [] ctxt p)

let type_check p f =
  if not (equal_form (type_infer p) f) then raise (Bad_proof "conclusion")
\end{verbatim}

There are two important things to comment in these programs:
\begin{enumerate}
\item We care about variable names using a context for the free
  variables and the \verb#lift_form# function for the bound ones as explained
  before.

\item The second important point is the use of \verb#unbox# together
with the \verb#lift_form# function to type-check the elimination rules.

We must use \verb#unbox# to match the formula coming from the
type-checking of the principal premise of the rule. Then, one
sub-formula of the matched formula must be used and we have to use
\verb#lift_form# for that.
Important remark: because of the use of \verb#lift_term# and
\verb#lift_form# functions, this algorithm is quadratic (at least), because
it calls \verb#lift_term# and \verb#lift_form# which are linear at
each elimination rule. As an exercise, the reader could rewrite the
\verb#type_infer# function, using a stack, to avoid this.

It is in fact a general problem when writing programs using bound
variables, we have often to make copy of objects (to adjust DeBruijn
indices, to rename variables, to ``relift'' them). And this is
important that \verb#bindlib# allow to easily notice this when using
the ``lifting'' functions and to allow to avoid them in a lot of cases,
bringing a substantial gain in efficiency.
\end{enumerate}

\section{Semantics}

Here is an equational specification of bindlib.
To give the semantics, we will use the following convention:
\begin{itemize}
\item variables are structure of type

\verb#'a variable = {id : int; name : string; f : 'a variable -> 'a}#

that are produced only by a function

\verb#new_var : ('a variable -> 'a) -> string -> 'a variable#

which always generates fresh \verb#id#.

\item We will use values written
 $\verb#unbox#_e$ where $e$ is an association list associating to a
 value of type \verb#'a variable# a value of type \verb#'a#.

In fact $e$ has type $\verb#env# = \exists \verb#('a.'a variable * 'a) list#$.

This is not a valid ML type, but it could be coded in ML. However, we
will use a search function \verb#assoc# (searching for variables)
which should have type \verb#'a variable -> env -> 'a#
which is not possible in  ML. However, in our case, this is type safe only because the same value can
not have type \verb#'a variable# and \verb#'b variable# if
$\verb#'a# \neq \verb#'b#$. This is enforced because the type
\verb#'a variable# is abstract.

\item Value of type \verb#context# will be set of strings. We
  consider that we have a function
\verb#fresh : string -> context -> string * context# such that
$\verb#fresh#\,s\,c = s',c'$ where \verb#s'# is not member of $c$,
has the same prefix that $s$ (only the numerical suffix of
$s$ is
changed) and $c'$ is the addition of $s'$ to the set $c$.

\item In the \verb#letvar# construct, when the \verb#as# keyword is
  ommited,
the name of the identifier is used as a \verb#string# for the variable
name (or as a \verb#string array# with a constant value for multiple binding).

\item In the semantics, we also use
\verb#map#, the standard map function on array
(\verb#Array.map#), and
\verb#fold_map : ('a -> 'b -> 'c * 'b) -> 'a array -> 'b -> 'c array * 'b#
which definition follows
\begin{verbatim}
let fold_map f tbl acc =
  let acc = ref acc in
  let fn x =
    let x', acc' = f x !acc in
    acc := acc';
    x'
  in
  let tbl' = Array.map fn tbl in
  tbl', !acc
\end{verbatim}

\end{itemize}

\begin{figure}
\begin{tabular}{rcl}
\verb#unbox# &=& $\verb#unbox#_{\verb#[]#}$\cr
$\verb#unbox#_e \verb#(#\verb#box#\;v\verb#)#$ &=& $v$\cr
$\verb#unbox#_e \verb#(#\verb#apply_box#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)#
\verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#unbox#_e \verb#(#\verb#bind_apply#\;f\;v\verb#)#$ &=& $\verb#(#\verb#unbox#_e\; f\verb#)# \verb#(#\verb#unbox#_e\; v\verb#)#$\cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#in#\;p$ &=& $\verb#let #id \verb# = new_var#\;f\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;id\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fresh
  }s\;ctxt\;\hbox{\tt in let }\;id\; \hbox{\tt = new\_var}\;f\;s\;\hbox{\tt in}\;p$} \cr
$\verb#name_of # v $ &=& v\verb#.name# \cr
$\verb#subst# \verb#(#\verb#unbox#_e \verb#(#\verb#bindvar#\;v\;\verb#in# f\verb#)#\verb#)# a$ &=& $\verb#unbox#_{\verb#(#v,a\verb#)#::e} f$\cr
$\verb#unbox#_e \verb#(#\verb#bindbox_of#\;v\verb#)#$ &=& $\verb#try assoc #v\;e \verb# with Not_found -> # v\verb#.f#\;v$ \cr
$\verb#unbox#_e \verb#(^#a_1, \dots, a_n\verb#^)#$ &=& $\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#unbox#_e \verb#[^#a_1; \dots; a_n\verb#^]#$ &=& $\verb#[#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#]#$ \cr
$\verb#unbox#_e \verb#[|^#a_1; \dots; a_n\verb#^|]#$ &=& $\verb#[|#\verb#unbox#_e\; a_1; \dots; \verb#unbox#_e\; a_n\verb#|]#$ \cr
$\verb#unbox#_e \verb#(#\verb#Cstr(^#a_1, \dots, a_n\verb#^)#\verb#)#$ &=& $\verb#Cstr#\verb#(#\verb#unbox#_e\; a_1, \dots, \verb#unbox#_e\; a_n\verb#)#$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#in#\;p$ &=&
  $\verb#let #ids\verb# = map (new_var#\;f\verb#)#\;s\;\verb#in#\;p$ \cr
$\verb#letvar#\;f\;ids\verb#(#n\verb#)#\;\verb#as#\;s\;\verb#for#\;ctxt\;\verb#in#\;p$&=&\cr
\multicolumn{3}{r}{$\hbox{\tt let}\;s',ctxt = \hbox{\tt fold\_map fresh }s\;ctxt\;\hbox{\tt in let }ids\;\hbox{\tt  = map (new\_var}\;f)\;s\;\hbox{\tt in}\;p$} \cr
\end{tabular}
\caption{Equational semantics for bindlib}
\end{figure}
\end{document}

WARNING: THIS EXAMPLE IS NOT YET PORTED TO bindlib 3.X series

Here is an implementation of 

***************************************************
*                                                 *
*        Combinatorics Reduction System           *
*                                                 *
*           Christophe Raffalli 98                *
*                                                 * 
***************************************************

It is given as an example of use of the bindlib library.

Here is how to use it:

I) Syntax of terms:
	
        x.t                   binder
        C t1 ... tn           application of a prefix constant of arity n
        t1 C                  application of an infix constant of arity 1
        t1 C t2               application of an infix constant of arity 2
        (t)                   parenthesis can be used for grouping
        t1 t2                 There is an invisible infix constant called
                              "application" of arity 2, this is how to use it!
        X[t1,..,tn]           Meta variables, can only be used to define
                              new rewrites rules

Moreover, a priority is associated to each constant (a floating point
number) The constant with the highest priority is capturing as much
argument as possible. for instance, if "C" is prefix with arity 2 and
priority 1 and "D" is infix with arity 2 and priority 2 then

    C t1 t2 D t3 = C t1 (t2 D t3)

Moreover, infix constant can be left associative, right associative or
non associative.

   "x.t" behaves as a prefix constant of priority 0
   "application" is an invisible infix constant of priority 10 and 
                 left associative.


II) Lexing

There is two kind of identifiers:

  alpha-numerical: [A-Za-Z][A-Za-Z0-9_']*
  other: [!%&$#+-/:<=>?@\~^|*]+
  
constant can use both kinds, bound variables can only use the
alpha-numerical ones.

Be careful "$#" is not the same as "$ #" !

  (* .... *) delimits comments.

III) Commands 

cst {name} {arity} {syntax} {priority};

  Defines a new constant:
    name: an identifier, the name of the new constant
    arity: an integer (number of argument of this constant)
    syntax: 
        Prefix        a prefix constant 
      | Infix         a non associative infix constant
      | LInfix        a left associative infix constant
      | RInfix        a right associative infix constant
    priority: a floating point number

let {name} = {term};
      
  Adds a define term
    name: the name of the new term
    term: the term !

red {term1} >> {term2};

  Adds a new rewrite rule: the term {term1} is rewritten in {term2}.
  {term1} can used meta variables with bound variables as argument and 
  each meta variable can only be used once. {term2} can use any variable 
  define used in {term1} with no restriction. Moreover, {term1} must start 
  by the application of a constant.

{term};

  reduce the term.

prn {term};

  print the term (without reducing it).

show {ident};

  print information about the constant named {ident}.

dump;

  print all defined terms, constants and rewriting rules.

load "{filename}";

  load the file whose name is "filename".

IV)

  examples:

    cst \ 1 Prefix 0.0;   (* a constant for "abstraction" *)

    red (\x.T[x]) U[] >> T[U[]];  (* beta reduction *)
    red \x.U[] x >> U[];          (* eta reduction *)

    (* definitions of some term about Church numerals *)
    let n0 = \f.\x.x;
    let S = \n.\f.\x.(f (n f x));
    let n1 = S n0;
    let n2 = S n1;
    let n3 = S n2;
    let n4 = S n3;
    let n5 = S n4;
    let add = \n. \m. \f. \x.n f (m f x);
    let mul = \n. \m. \f.n (m f);
    let pred = \n.n 
	  (\p. \x. \y.p (S x) x)
	  (\x. \y.y) n0 n0;

    (* let's do some computing *)
    n5;
    n5 pred n5;

    cst $ 0 Prefix 0.0;  (* a constant for the empty list *)
    cst :: 2 RInfix 6.0; (* a constant for "cons" *)
    cst @ 2 RInfix 5.0;  (* a constant for append *)

    (* the rewriting defining append *)
    red $ @ U[] >> U[];	
    red (X[]::L[]) @ L'[] >> X[]::(L[] @ L'[]);

    (* let's try it *)
    n1::n2:: $ @ $;  (* don't forget the white space in ":: $" ! *)

    (* let's define "map" *)
    cst map 0 Prefix 0.0;
    red map f[] $ >> $;
    red map f[] (X[]::L[]) >> (f[] X[])::(map f[] L[]);

    (* let's try it *)
    \f.map f (n1::n2:: $);

V)

  Organisation of the file:

    bindlib.ml: the bindlib library
    genlex.ml:  the lexical analyser
    file.ml:    the tool used to load files
    basic.ml:   definition of the type of terms
    print.ml:   printing of terms
    globals.ml: some code about the global environment
    reduce.ml:  the rewriting algorithm (using parallel reduction)
    action.ml:  the code corresponding to each commands
    crs.ml:     the "main" file

---




